local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
 
local GrabEvents = ReplicatedStorage:WaitForChild("GrabEvents")
local MenuToys = ReplicatedStorage:WaitForChild("MenuToys")
local CharacterEvents = ReplicatedStorage:WaitForChild("CharacterEvents")
local SetNetworkOwner = GrabEvents:WaitForChild("SetNetworkOwner")
local Struggle = CharacterEvents:WaitForChild("Struggle")
local CreateLine = GrabEvents:WaitForChild("CreateGrabLine")
local DestroyLine = GrabEvents:WaitForChild("DestroyGrabLine")
local DestroyToy = MenuToys:WaitForChild("DestroyToy")
 
local localPlayer = Players.LocalPlayer
local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()
 
localPlayer.CharacterAdded:Connect(function(character)
    playerCharacter = character
end)
 
local AutoRecoverDroppedPartsCoroutine
local connectionBombReload
local reloadBombCoroutine
local antiExplosionConnection
local poisonAuraCoroutine
local deathAuraCoroutine
local reloadBombCoroutine
local poisonCoroutines = {}
local strengthConnection
local coroutineRunning = false
local autoStruggleCoroutine
local autoDefendCoroutine
local auraCoroutine
local gravityCoroutine
local kickCoroutine
local kickGrabCoroutine
local hellSendGrabCoroutine
local anchoredParts = {}
local anchoredConnections = {}
local compiledGroups = {}
local compileConnections = {}
local compileCoroutine
local fireAllCoroutine
local connections = {}
local renderSteppedConnections = {}
local ragdollAllCoroutine
local crouchJumpCoroutine
local crouchSpeedCoroutine
local anchorGrabCoroutine
local poisonGrabCoroutine
local ufoGrabCoroutine
local burnPart
local fireGrabCoroutine
local noclipGrabCoroutine
local antiKickCoroutine
local kickGrabConnections = {}
local blobmanCoroutine
local lighBitSpeedCoroutine
local lightbitpos = {}
local lightbitparts = {}
local lightbitcon
local lightbitcon2
local lightorbitcon
local bodyPositions = {}
local alignOrientations = {}
 
 
 
local decoyOffset = 15
local stopDistance = 5
local circleRadius = 10
local circleSpeed = 2
local auraToggle = 1
local crouchWalkSpeed = 50
local crouchJumpPower = 50
local kickMode = 1
local auraRadius = 20
local lightbit = 0.3125
local lightbitoffset = 1
local lightbitradius = 20
local usingradius = lightbitradius
 



local followMode = true
local toysFolder = workspace:FindFirstChild(localPlayer.Name.."SpawnedInToys")
local playerList = {}
local selection 
local blobman 
local platforms = {}
local ownedToys = {}
local bombList = {}
_G.ToyToLoad = "BombMissile"
_G.MaxMissiles = 9
_G.BlobmanDelay = 0
 
 
 
local function isDescendantOf(target, other)
    local currentParent = target.Parent
    while currentParent do
        if currentParent == other then
            return true
        end
        currentParent = currentParent.Parent
    end
    return false
end
local function DestroyT(toy)
    local toy = toy or toysFolder:FindFirstChildWhichIsA("Model")
    DestroyToy:FireServer(toy)
end
 
 
local function getDescendantParts(descendantName)
    local parts = {}
    for _, descendant in ipairs(workspace.Map:GetDescendants()) do
        if descendant:IsA("Part") and descendant.Name == descendantName then
            table.insert(parts, descendant)
        end
    end
    return parts
end
 
local poisonHurtParts = getDescendantParts("PoisonHurtPart")
local paintPlayerParts = getDescendantParts("PaintPlayerPart")
 
local function updatePlayerList()
    playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(playerList, player.Name)
    end
end
 
local function onPlayerAdded(player)
    table.insert(playerList, player.Name)
end
 
local function onPlayerRemoving(player)
    for i, name in ipairs(playerList) do
        if name == player.Name then
            table.remove(playerList, i)
            break
        end
    end
end
 
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)
for i, v in pairs(localPlayer:WaitForChild("PlayerGui"):WaitForChild("MenuGui"):WaitForChild("Menu"):WaitForChild("TabContents"):WaitForChild("Toys"):WaitForChild("Contents"):GetChildren()) do
    if v.Name ~= "UIGridLayout" then
        ownedToys[v.Name] = true
    end
end
 
local function getNearestPlayer()
    local nearestPlayer
    local nearestDistance = math.huge
 
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (playerCharacter.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < nearestDistance then
                nearestDistance = distance
                nearestPlayer = player
            end
        end
    end
 
    return nearestPlayer
end
 
local function cleanupConnections(connectionTable)
    for _, connection in ipairs(connectionTable) do
        connection:Disconnect()
    end
    connectionTable = {}
end
 

 
local function spawnItem(itemName, position, orientation)
    task.spawn(function()
        local cframe = CFrame.new(position)
        local rotation = Vector3.new(0, 90, 0)
        ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(itemName, cframe, rotation)
    end)
end
 
local function arson(part)
    if not toysFolder:FindFirstChild("Campfire") then
        spawnItem("Campfire", Vector3.new(-72.9304581, -5.96906614, -265.543732))
    end
    local campfire = toysFolder:FindFirstChild("Campfire")
    burnPart = campfire:FindFirstChild("FirePlayerPart") or campfire.FirePlayerPart
    burnPart.Size = Vector3.new(7, 7, 7)
    burnPart.Position = part.Position
    task.wait(0.3)
    burnPart.Position = Vector3.new(0, -50, 0)
end
 
local function handleCharacterAdded(player)
    local characterAddedConnection = player.CharacterAdded:Connect(function(character)
        local hrp = character:WaitForChild("HumanoidRootPart")
        local fpp = hrp:WaitForChild("FirePlayerPart")
        fpp.Size = Vector3.new(4.5, 5, 4.5)
        fpp.CollisionGroup = "1"
        fpp.CanQuery = true
    end)
    table.insert(kickGrabConnections, characterAddedConnection)
end
 
local function kickGrab()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = player.Character.HumanoidRootPart
            if hrp:FindFirstChild("FirePlayerPart") then
                local fpp = hrp.FirePlayerPart
                fpp.Size = Vector3.new(4.5, 5.5, 4.5)
                fpp.CollisionGroup = "1"
                fpp.CanQuery = true
            end
        end
        handleCharacterAdded(player)
    end
 
    local playerAddedConnection = Players.PlayerAdded:Connect(handleCharacterAdded)
    table.insert(kickGrabConnections, playerAddedConnection)
end
 
local function grabHandler(grabType)
    while true do
        local success, err = pcall(function()
            local child = workspace:FindFirstChild("GrabParts")
            if child and child.Name == "GrabParts" then
                local grabPart = child:FindFirstChild("GrabPart")
                local grabbedPart = grabPart:FindFirstChild("WeldConstraint").Part1
                local head = grabbedPart.Parent:FindFirstChild("Head")
                if head then
                    while workspace:FindFirstChild("GrabParts") do
                        local partsTable = grabType == "poison" and poisonHurtParts or paintPlayerParts
                        for _, part in pairs(partsTable) do
                            part.Size = Vector3.new(2, 2, 2)
                            part.Transparency = 1
                            part.Position = head.Position
                        end
                        wait()
                        for _, part in pairs(partsTable) do
                            part.Position = Vector3.new(0, -200, 0)
                        end
                    end
                    for _, part in pairs(partsTable) do
                        part.Position = Vector3.new(0, -200, 0)
                    end
                end
            end
        end)
        wait()
    end
end
 
local function fireGrab()
    while true do
        local success, err = pcall(function()
            local child = workspace:FindFirstChild("GrabParts")
            if child and child.Name == "GrabParts" then
                local grabPart = child:FindFirstChild("GrabPart")
                local grabbedPart = grabPart:FindFirstChild("WeldConstraint").Part1
                local head = grabbedPart.Parent:FindFirstChild("Head")
                if head then
                    arson(head)
                end
            end
        end)
        wait()
    end
end
 
local function noclipGrab()
    while true do
        local success, err = pcall(function()
            local child = workspace:FindFirstChild("GrabParts")
            if child and child.Name == "GrabParts" then
                local grabPart = child:FindFirstChild("GrabPart")
                local grabbedPart = grabPart:FindFirstChild("WeldConstraint").Part1
                local character = grabbedPart.Parent
                if character.HumanoidRootPart then
                    while workspace:FindFirstChild("GrabParts") do
                        for _, part in pairs(character:GetChildren()) do
                            if part:IsA("BasePart") then
                                part.CanCollide = false
                            end
                        end
                        wait()
                    end
                    for _, part in pairs(character:GetChildren()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                        end
                    end
                end
            end
        end)
        wait()
    end
end
local function spawnItemCf(itemName, cframe)
    task.spawn(function()
        local rotation = Vector3.new(0, 0, 0)
        ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(itemName, cframe, rotation)
    end)
end
 
local function fireAll()
    while true do
        local success, err = pcall(function()
            if toysFolder:FindFirstChild("Campfire") then
                DestroyT(toysFolder:FindFirstChild("Campfire"))
                wait(0.5)
            end
            spawnItemCf("Campfire", playerCharacter.Head.CFrame)
            local campfire = toysFolder:WaitForChild("Campfire")
            local firePlayerPart
            for _, part in pairs(campfire:GetChildren()) do
                if part.Name == "FirePlayerPart" then
                    part.Size = Vector3.new(10, 10, 10)
                    firePlayerPart = part
                    break
                end
            end
            local originalPosition = playerCharacter.Torso.Position
            SetNetworkOwner:FireServer(firePlayerPart, firePlayerPart.CFrame)
            playerCharacter:MoveTo(firePlayerPart.Position)
            wait(0.3)
            playerCharacter:MoveTo(originalPosition)
            local bodyPosition = Instance.new("BodyPosition")
            bodyPosition.P = 20000
            bodyPosition.Position = playerCharacter.Head.Position + Vector3.new(0, 600, 0)
            bodyPosition.Parent = campfire.Main
            while true do
                for _, player in pairs(Players:GetChildren()) do
                    pcall(function()
                        bodyPosition.Position = playerCharacter.Head.Position + Vector3.new(0, 600, 0)
                        if player.Character and player.Character.HumanoidRootPart and player.Character ~= playerCharacter then
                            firePlayerPart.Position = player.Character.HumanoidRootPart.Position or player.Character.Head.Position
                            wait()
                        end
                    end)
                end  
                wait()
            end
        end)
        if not success then
            warn("Error in fireAll: " .. tostring(err))
        end
        wait()
    end
end
 
local function createHighlight(parent)
    local highlight = Instance.new("Highlight")
    highlight.DepthMode = Enum.HighlightDepthMode.Occluded
    highlight.FillTransparency = 1
    highlight.Name = "Highlight"
    highlight.OutlineColor = Color3.new(0, 0, 1)
    highlight.OutlineTransparency = 0.5
    highlight.Parent = parent
    print("created highlight and set on "..parent.Name)
    return highlight
end
 
local function onPartOwnerAdded(descendant, primaryPart)
    if descendant.Name == "PartOwner" and descendant.Value ~= localPlayer.Name then
        local highlight = primaryPart:FindFirstChild("Highlight") or U.GetDescendant(U.FindFirstAncestorOfType(primaryPart, "Model"), "Highlight", "Highlight")
        if highlight then
            if descendant.Value ~= localPlayer.Name then
                highlight.OutlineColor = Color3.new(1, 0, 0)
            else
                highlight.OutlineColor = Color3.new(0, 0, 1)
            end
        end
    end
end
 
local function createBodyMovers(part, position, rotation)
    local bodyPosition = Instance.new("BodyPosition")
    local bodyGyro = Instance.new("BodyGyro")
 
    bodyPosition.P = 15000
    bodyPosition.D = 200
    bodyPosition.MaxForce = Vector3.new(5000000, 5000000, 5000000)
    bodyPosition.Position = position
    bodyPosition.Parent = part
 
    bodyGyro.P = 15000
    bodyGyro.D = 200
    bodyGyro.MaxTorque = Vector3.new(5000000, 5000000, 5000000)
    bodyGyro.CFrame = rotation
    bodyGyro.Parent = part
end
 
local function anchorGrab()
    while true do
        pcall(function()
            local grabParts = workspace:FindFirstChild("GrabParts")
            if not grabParts then return end
 
            local grabPart = grabParts:FindFirstChild("GrabPart")
            if not grabPart then return end
 
            local weldConstraint = grabPart:FindFirstChild("WeldConstraint")
            if not weldConstraint or not weldConstraint.Part1 then return end
 
            local primaryPart = weldConstraint.Part1.Name == "SoundPart" and weldConstraint.Part1 or weldConstraint.Part1.Parent.SoundPart or weldConstraint.Part1.Parent.PrimaryPart or weldConstraint.Part1
            if not primaryPart then return end
            if primaryPart.Anchored then return end
 
            if isDescendantOf(primaryPart, workspace.Map) then return end
            for _, player in pairs(Players:GetChildren()) do
                if isDescendantOf(primaryPart, player.Character) then return end
            end
            local t = true
            for _, v in pairs(primaryPart:GetDescendants()) do
                if table.find(anchoredParts, v) then
                    t = false
                end
 
            end
            if t and not table.find(anchoredParts, primaryPart) then
                local target 
                if U.FindFirstAncestorOfType(primaryPart, "Model") and U.FindFirstAncestorOfType(primaryPart, "Model") ~= workspace then
                    target = U.FindFirstAncestorOfType(primaryPart, "Model")
                else
                    target = primaryPart
                end
 
                local highlight = createHighlight(target)
                table.insert(anchoredParts, primaryPart)
 
                print(target)
                local connection = target.DescendantAdded:Connect(function(descendant)
                    onPartOwnerAdded(descendant, primaryPart)
                end)
                table.insert(anchoredConnections, connection)
            end
 
 
            if U.FindFirstAncestorOfType(primaryPart, "Model") and U.FindFirstAncestorOfType(primaryPart, "Model") ~= workspace then 
                for _, child in ipairs(U.FindFirstAncestorOfType(primaryPart, "Model"):GetDescendants()) do
                    if child:IsA("BodyPosition") or child:IsA("BodyGyro") then
                        child:Destroy()
                    end
                end
            else
                for _, child in ipairs(primaryPart:GetChildren()) do
                    if child:IsA("BodyPosition") or child:IsA("BodyGyro") then
                        child:Destroy()
                    end
                end
            end
 
            while workspace:FindFirstChild("GrabParts") do
                wait()
            end
            createBodyMovers(primaryPart, primaryPart.Position, primaryPart.CFrame)
        end)
        wait()
    end
end
local function anchorKickGrab()
    while true do
        pcall(function()
            local grabParts = workspace:FindFirstChild("GrabParts")
            if not grabParts then return end
 
            local grabPart = grabParts:FindFirstChild("GrabPart")
            if not grabPart then return end
 
            local weldConstraint = grabPart:FindFirstChild("WeldConstraint")
            if not weldConstraint or not weldConstraint.Part1 then return end
 
            local primaryPart = weldConstraint.Part1
            if not primaryPart then return end
 
            if isDescendantOf(primaryPart, workspace.Map) then return end
            if primaryPart.Name ~= "FirePlayerPart" then return end
 
            for _, child in ipairs(primaryPart:GetChildren()) do
                if child:IsA("BodyPosition") or child:IsA("BodyGyro") then
                    child:Destroy()
                end
            end
 
            while workspace:FindFirstChild("GrabParts") do
                wait()
            end
            createBodyMovers(primaryPart, primaryPart.Position, primaryPart.CFrame)
        end)
        wait()
    end
end
 
local function cleanupAnchoredParts()
    for _, part in ipairs(anchoredParts) do
        if part then
            if part:FindFirstChild("BodyPosition") then
                part.BodyPosition:Destroy()
            end
            if part:FindFirstChild("BodyGyro") then
                part.BodyGyro:Destroy()
            end
            local highlight = part:FindFirstChild("Highlight") or part.Parent and part.Parent:FindFirstChild("Highlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
 
    cleanupConnections(anchoredConnections)
    anchoredParts = {}
end
 
local function updateBodyMovers(primaryPart)
    for _, group in ipairs(compiledGroups) do
        if group.primaryPart and group.primaryPart == primaryPart then
            for _, data in ipairs(group.group) do
                local bodyPosition = data.part:FindFirstChild("BodyPosition")
                local bodyGyro = data.part:FindFirstChild("BodyGyro")
                if bodyPosition then
                    bodyPosition.Position = (primaryPart.CFrame * data.offset).Position
                end
                if bodyGyro then
                    bodyGyro.CFrame = primaryPart.CFrame * data.offset
                end
            end
        end
    end
end
 
local function compileGroup()
    if #anchoredParts == 0 then 
        OrionLib:MakeNotification({Name = "Error", Content = "No anchored parts found", Image = "rbxassetid://4483345998", Time = 5})
    else
        OrionLib:MakeNotification({Name = "Success", Content = "Compiled "..#anchoredParts.." Toys together", Image = "rbxassetid://4483345998", Time = 5})
    end
 
    local primaryPart = anchoredParts[1]
    if not primaryPart then return end
 
    local highlight =  primaryPart:FindFirstChild("Highlight") or primaryPart.Parent:FindFirstChild("Highlight")
    if not highlight then
        highlight = createHighlight(primaryPart.Parent:IsA("Model") and primaryPart.Parent or primaryPart)
    end
    highlight.OutlineColor = Color3.new(0, 1, 0) 
 
 
    local group = {}
    for _, part in ipairs(anchoredParts) do
        if part ~= primaryPart then
            local offset = primaryPart.CFrame:toObjectSpace(part.CFrame)
            table.insert(group, {part = part, offset = offset})
        end
    end
    table.insert(compiledGroups, {primaryPart = primaryPart, group = group})
 
    local connection = primaryPart:GetPropertyChangedSignal("CFrame"):Connect(function()
        updateBodyMovers(primaryPart)
    end)
    table.insert(compileConnections, connection)
 
    local renderSteppedConnection = RunService.Heartbeat:Connect(function()
        updateBodyMovers(primaryPart)
    end)
    table.insert(renderSteppedConnections, renderSteppedConnection)
end
 
local function cleanupCompiledGroups()
    for _, groupData in ipairs(compiledGroups) do
        for _, data in ipairs(groupData.group) do
            if data.part then
                if data.part:FindFirstChild("BodyPosition") then
                    data.part.BodyPosition:Destroy()
                end
                if data.part:FindFirstChild("BodyGyro") then
                    data.part.BodyGyro:Destroy()
                end
            end
        end
        if groupData.primaryPart and groupData.primaryPart.Parent then
            local highlight = groupData.primaryPart:FindFirstChild("Highlight") or groupData.primaryPart.Parent:FindFirstChild("Highlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
 
    cleanupConnections(compileConnections)
    cleanupConnections(renderSteppedConnections)
    compiledGroups = {}
end
 
local function compileCoroutineFunc()
    while true do
        pcall(function()
            for _, groupData in ipairs(compiledGroups) do
                updateBodyMovers(groupData.primaryPart)
            end
        end)
        wait()
    end
end
 
local function unanchorPrimaryPart()
    local primaryPart = anchoredParts[1]
    if not primaryPart then return end
    if primaryPart:FindFirstChild("BodyPosition") then
        primaryPart.BodyPosition:Destroy()
    end
    if primaryPart:FindFirstChild("BodyGyro") then
        primaryPart.BodyGyro:Destroy()
    end
    local highlight = primaryPart.Parent:FindFirstChild("Highlight") or primaryPart:FindFirstChild("Highlight")
    if highlight then
        highlight:Destroy()
    end
end
local function recoverParts()
    while true do
        local success, err = pcall(function()
            local character = localPlayer.Character
            if character and character:FindFirstChild("Head") and character:FindFirstChild("HumanoidRootPart") then
                local head = character.Head
                local humanoidRootPart = character.HumanoidRootPart
 
                for _, partModel in pairs(anchoredParts) do
                    coroutine.wrap(function()
                        if partModel then
                            local distance = (partModel.Position - humanoidRootPart.Position).Magnitude
                            if distance <= 30 then
                                local highlight = partModel:FindFirstChild("Highlight") or partModel.Parent:FindFirstChild("Highlight")
                                if highlight and highlight.OutlineColor == Color3.new(1, 0, 0) then
                                    SetNetworkOwner:FireServer(partModel, partModel.CFrame)
                                    if partModel:WaitForChild("PartOwner") and partModel.PartOwner.Value == localPlayer.Name then
                                        highlight.OutlineColor = Color3.new(0, 0, 1)
                                        print("yoyoyo set and r eady")
                                    end
                                end
                            end
                        end
                    end)()
                end
            end
        end)
        wait(0.02)
    end
end
local function ragdollAll()
    while true do
        local success, err = pcall(function()
            if not toysFolder:FindFirstChild("FoodBanana") then
                spawnItem("FoodBanana", Vector3.new(-72.9304581, -5.96906614, -265.543732))
            end
            local banana = toysFolder:WaitForChild("FoodBanana")
            local bananaPeel
            for _, part in pairs(banana:GetChildren()) do
                if part.Name == "BananaPeel" and part:FindFirstChild("TouchInterest") then
                    part.Size = Vector3.new(10, 10, 10)
                    part.Transparency = 1
                    bananaPeel = part
                    break
                end
            end
            local bodyPosition = Instance.new("BodyPosition")
            bodyPosition.P = 20000
            bodyPosition.Parent = banana.Main
            while true do
                for _, player in pairs(Players:GetChildren()) do
                    pcall(function()
                        if player.Character and player.Character ~= playerCharacter then
                            bananaPeel.Position = player.Character.HumanoidRootPart.Position or player.Character.Head.Position
                            bodyPosition.Position = playerCharacter.Head.Position + Vector3.new(0, 600, 0)
                            wait()
                        end
                    end)
                end   
                wait()
            end
        end)
        if not success then
            warn("Error in ragdollAll: " .. tostring(err))
        end
        wait()
    end
end
local function reloadMissile(bool)
    if bool then
        if not ownedToys[_G.ToyToLoad] then
            OrionLib:MakeNotification({
                Name = "Missing toy",
                Content = "You do not own the ".._G.ToyToLoad.." toy.",
                Image = "rbxassetid://4483345998",
                Time = 3
            })
            return
        end
 
        if not reloadBombCoroutine then
            reloadBombCoroutine = coroutine.create(function()
                connectionBombReload = toysFolder.ChildAdded:Connect(function(child)
                    if child.Name == _G.ToyToLoad and child:WaitForChild("ThisToysNumber", 1) then
                        if child.ThisToysNumber.Value == (toysFolder.ToyNumber.Value - 1) then
                            local connection2
                            connection2 = toysFolder.ChildRemoved:Connect(function(child2)
                                if child2 == child then
                                    connection2:Disconnect()
                                end
                            end)
 
                            SetNetworkOwner:FireServer(child.Body, child.Body.CFrame)
                            local waiting = child.Body:WaitForChild("PartOwner", 0.5)
                            local connection = child.DescendantAdded:Connect(function(descendant)
                                if descendant.Name == "PartOwner" then
                                    if descendant.Value ~= localPlayer.Name then
                                        DestroyT(child)
                                        connection:Disconnect()
                                    end
                                end
                            end)
                            Debris:AddItem(connectio, 60)
                            if waiting and waiting.Value == localPlayer.Name then
                                for _, v in pairs(child:GetChildren()) do
                                    if v:IsA("BasePart") then
                                        v.CanCollide = false
                                    end
                                end
                                child:SetPrimaryPartCFrame(CFrame.new(-72.9304581, -3.96906614, -265.543732))
                                wait(0.2)
                                for _, v in pairs(child:GetChildren()) do
                                    if v:IsA("BasePart") then
                                        v.Anchored = true
                                    end
                                end
                                table.insert(bombList, child)
                                child.AncestryChanged:Connect(function()
                                    if not child.Parent then
                                        for i, bomb in ipairs(bombList) do
                                            if bomb == child then
                                                table.remove(bombList, i)
                                                break
                                            end
                                        end
                                    end
                                end)
                                connection2:Disconnect()
                            else
                                DestroyT(child)
                            end
                        end
                    end
                end)
 
                while true do
                    if localPlayer.CanSpawnToy and localPlayer.CanSpawnToy.Value and #bombList < _G.MaxMissiles and playerCharacter:FindFirstChild("Head") then
                        spawnItemCf(_G.ToyToLoad, playerCharacter.Head.CFrame or playerCharacter.HumanoidRootPart.CFrame)
                    end
                    RunService.Heartbeat:Wait()
                end
            end)
            coroutine.resume(reloadBombCoroutine)
        end
    else
        if reloadBombCoroutine then
            coroutine.close(reloadBombCoroutine)
            reloadBombCoroutine = nil
        end
        if connectionBombReload then
            connectionBombReload:Disconnect()
        end
    end
end


 
local blobalter = 1
local function blobGrabPlayer(player, blobman)
    if blobalter == 1 then
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local args = {
                [1] = blobman:FindFirstChild("LeftDetector"),
                [2] = player.Character:FindFirstChild("HumanoidRootPart"),
                [3] = blobman:FindFirstChild("LeftDetector"):FindFirstChild("LeftWeld")
            }
            blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
            blobalter = 2
        end
    else
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local args = {
                [1] = blobman:FindFirstChild("RightDetector"),
                [2] = player.Character:FindFirstChild("HumanoidRootPart"),
                [3] = blobman:FindFirstChild("RightDetector"):FindFirstChild("RightWeld")
            }
            blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
            blobalter = 1
        end
    end
end


local RS = game:GetService("ReplicatedStorage")
local RF = game:GetService("ReplicatedFirst")
local PS = game:GetService("Players")
local DB = game:GetService("Debris")
local Tween = game:GetService("TweenService")
local uis = game:GetService("UserInputService")
OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/VerbalHubz/Verbal-Hub/refs/heads/main/verbal%20hub%20v2%20orion", true))()
local R = game:GetService("RunService")
local request = (syn and syn.request) or http and http.request or http_request or (fluxus and fluxus.request) or request
local W = game:GetService("Workspace")
local Cam = workspace.CurrentCamera
local downDir = Vector3.new(0, -1, 0)
local lastH
local lastHitTime = tick()
local raycastParams = RaycastParams.new()
local xcl
local ycl
local zcl
local offPos = Vector3.new(xcl, ycl, zcl)
local freeze
local frt


local CE = RS:WaitForChild("CharacterEvents")
local localPlayer = PS.LocalPlayer
local localChar = localPlayer.Character
local HR = localChar:WaitForChild("HumanoidRootPart")
local localName = localPlayer.Name
local localTFolder = workspace:WaitForChild(localName .. "SpawnedInToys")
local Mouse = localPlayer:GetMouse()
local hum = localChar:WaitForChild("Humanoid")


local SpawnToy = RS:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction")
local DeleteToy = RS:WaitForChild("MenuToys"):WaitForChild("DestroyToy")


local CreateGrabLine = RS:WaitForChild("GrabEvents"):WaitForChild("CreateGrabLine")
local DestroyGrabLine = RS:WaitForChild("GrabEvents"):WaitForChild("DestroyGrabLine")
local SetNetworkOwnership = RS:WaitForChild("GrabEvents"):WaitForChild("SetNetworkOwner")
local ExtendLine = RS:WaitForChild("GrabEvents"):WaitForChild("ExtendGrabLine")


local SE = CE:WaitForChild("Struggle")



_G.SuperStrength = nil
_G.AntiGrab = nil
_G.AntiExplosion = nil
_G.AntiBurn = nil
_G.KickAttacker = nil
_G.AutoAttacker = nil
_G.KillAttacker = nil
_G.Poison_Grab = nil
_G.KickGrab = nil
_G.PaintGrab = nil
_G.MasslessGrab = nil
_G.BlobmanSpeed = nil
_G.BlobAntiE = nil
_G.Burn_Grab = nil
_G.Radioactive_Grab = nil
_G.Kill_Grab = nil
_G.WalkSpeed = nil
_G.InfiniteJump = nil
_G.Teleport = nil
_G.KickAura = nil
_G.FlingAura = nil
_G.BurnAura = nil
_G.AttractionAura = nil
_G.KillAura = nil
_G.PaintAura = nil
_G.WalkspeedAura = nil
_G.PoisionAura = nil
local autocl
local SIL
local dist = 30



getgenv().Multiplier = 0.5
_G.Strength = nil
_G.WalkA = nil
_G.Jpower = nil
_G.BSpeed = nil



local function checkFirePart()
    for i, toy in pairs(localTFolder:GetChildren()) do
        if toy.Name == "Campfire" then
            local firePlayerPart = toy:FindFirstChild("FirePlayerPart")
            if firePlayerPart and firePlayerPart:FindFirstChild("CanBurn") then
                if not firePlayerPart.CanBurn.Value then
                    DeleteToy:FireServer(toy)
                end
            end
        end
    end

    local campfire = localTFolder:FindFirstChild("Campfire")
    if campfire then
        local firePlayerPart = campfire:FindFirstChild("FirePlayerPart")
        if firePlayerPart and firePlayerPart:FindFirstChild("CanBurn") then
            if firePlayerPart.CanBurn.Value then
                return campfire
            end
        end
    else
        local args = {
            [1] = "Campfire",
            [2] = CFrame.new(508.073517, 67.2614441, -261.901917, -0.133750245, -0.471861839, 0.871468484, -3.7252903e-09, 0.879369617, 0.476139903, -0.991015136, 0.0636838302, -0.117615893),
            [3] = Vector3.new(0, 97.69000244140625, 0)
        }

        repeat
            local spawnResult = SpawnToy:InvokeServer(unpack(args))
            if spawnResult == "YouDontOwnToy" then
                for i, toy in pairs(workspace:GetChildren()) do
                    if toy:FindFirstChild("Campfire") then
                        local firePlayerPart = toy:FindFirstChild("FirePlayerPart")
                        if firePlayerPart and firePlayerPart:FindFirstChild("CanBurn") then
                            if firePlayerPart.CanBurn.Value then
                                campfire = toy
                                break
                            end
                        end
                    end
                end

                if campfire then
                    break
                end
            else
                campfire = localTFolder:FindFirstChild("Campfire")
            end

            wait(1)
        until campfire ~= nil

        return campfire
    end
end

local function NightHub()

local anfr = W.Map.Hole.PoisonBigHole.ExtinguishPart
anfr.Size = Vector3.new(0.5, 0.5, 0.5)
anfr.Transparency = 1
anfr.Tex.Transparency = 1

local function STS()
local Hitbox = {"Head", "Torso", "Left Leg", "Right Leg"}

local function GetClosest()
    local Target, Closest = nil, math.huge
    
    for _, player in pairs(PS:GetPlayers()) do
        if player.Name ~= localPlayer.Name and player.Character and localPlayer and localPlayer.Character and localPlayer.Character.HumanoidRootPart then
            local playerPosition = localPlayer.Character.HumanoidRootPart.Position
            local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart then
                local screenPos, onScreen = Cam:WorldToScreenPoint(humanoidRootPart.Position)
                
                if onScreen then
                    local distance = (playerPosition - humanoidRootPart.Position).magnitude
                    
                    if distance < Closest then
                        Closest = distance
                        Target = player
                    end
                end
            end
        end
    end
    
    return Target
end

local Target
local part
local partn
local ch

R.RenderStepped:Connect(function()
    Target = GetClosest()
end)

local function CalculateDirection(Origin, Destination, Length)
    return (Destination - Origin).Unit * Length
end

local __namecall
__namecall = hookmetamethod(game, "__namecall", function(...)
    local args = {...}
    local self = args[1]
    local method = getnamecallmethod()
    
    if self == workspace and not checkcaller() and method == "Raycast" and Target and Target.Character and Target.Character.HumanoidRootPart and localPlayer.Character.HumanoidRootPart and Target.Character.Humanoid and Target.Character.Humanoid.Health > 0 and not Target.InPlot.Value and SIL then
        local playerPosition = localPlayer.Character.HumanoidRootPart.Position
        local targetPosition = Target.Character.HumanoidRootPart.Position
        local distance = (playerPosition - targetPosition).magnitude
        part = math.random(1, #Hitbox)
        partn = Hitbox[part]
        ch = Target.Character[partn]

        if distance <= dist and ch then
            args[3] = CalculateDirection(args[2], Target.Character[partn].Position, 1000)
            args[4] = RaycastParams.new()
            args[4].FilterDescendantsInstances = {Target.Character}
            args[4].FilterType = Enum.RaycastFilterType.Include
            part = nil
            partn = nil
            ch = nil
        end
    end

    return __namecall(unpack(args))
end)
end


Window = OrionLib:MakeWindow({
    Name = "Scripture Hub V0",
    HidePremium = false,
    SaveConfig = true,
    IntroEnabled = true,
    IntroText = "Welcome to Scripture V1!",
    IntroIcon = "rbxassetid://82778010291487",
    ConfigFolder = "Ninja Config"
})




local ReplicatedStorage = game:GetService("ReplicatedStorage")
local GrabEvent = ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("CreateGrabLine")
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local workspace = game:GetService("Workspace")

local scriptTab = Window:MakeTab({
	Name = "Script",
	Icon = "rbxassetid://7733920644",
	PremiumOnly = false
})

scriptTab:AddButton({
	Name = "System Broken",
	Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/biel99lol/My-scripts/refs/heads/main/Script%20Broken"))()
print("script Loading...")
  	end    
})

scriptTab:AddButton({
	Name = "Infinite Yield",
	Callback = function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
print("script Loading...")
  	end    
})

scriptTab:AddButton({
    Name = "Rejoin",
    Callback = function()
        print("Rejoin Game...")
        local player = game.Players.LocalPlayer
        local teleportService = game:GetService("TeleportService")
        local placeId = game.PlaceId
        

        teleportService:Teleport(placeId, player)
    end    
})



local GrabTab = Window:MakeTab({Name = "Grab", Icon =  "rbxassetid://7733954884", PremiumOnly = false})

GrabTab:AddSlider({
    Name = "Super Strenght",
    Min = 400,
    Max = 10000,  
    Default = 400,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 100,
    ValueName = "Força",
    Callback = function(Value)
        strength = Value  
        print("Força atual: " .. strength)
    end    
})


GrabTab:AddToggle({
    Name = "Enable Super Strenght",
    Default = false,
    Callback = function(Value)
        fling = Value  
        print("Força habilitada: " .. tostring(fling))
    end    
})


Workspace.ChildAdded:Connect(function(model)
    if model.Name == "GrabParts" then
        local part_to_impulse = model:FindFirstChild("GrabPart") and model["GrabPart"]["WeldConstraint"].Part1

        if part_to_impulse then
            print("Part found!")

            local velocityObj = Instance.new("BodyVelocity", part_to_impulse)
            
            model:GetPropertyChangedSignal("Parent"):Connect(function()
                if not model.Parent then
                    if fling then
                        print("Launched!")
                        velocityObj.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                        velocityObj.Velocity = Workspace.CurrentCamera.CFrame.lookVector * strength
                        Debris:AddItem(velocityObj, 1)
                    else
                        velocityObj.MaxForce = Vector3.new(0, 0, 0)
                        Debris:AddItem(velocityObj, 1)
                        print("Cancel Launch!")
                    end
                end
            end)
        end
    end
end)


GrabTab:AddParagraph("W", "Grab Add")



GrabTab:AddToggle({
    Name = "Poison Grab",
    Default = false,
    Save = true,
    Color = Color3.fromRGB(240, 0, 0),
    Flag = "PoisonGrab",
    Callback = function(enabled)
        if enabled then
            poisonGrabCoroutine = coroutine.create(function() grabHandler("poison") end)
            coroutine.resume(poisonGrabCoroutine)
        else
            if poisonGrabCoroutine then
                coroutine.close(poisonGrabCoroutine)
                poisonGrabCoroutine = nil
                for _, part in pairs(poisonHurtParts) do
                    part.Position = Vector3.new(0, -200, 0)
                end
            end
        end
    end
})

GrabTab:AddToggle({
    Name = "Radioactive Grab",
    Default = false,
    Color = Color3.fromRGB(240, 0, 0),
    Save = true,
    Flag = "RadioactiveGrab",
    Callback = function(enabled)
        if enabled then
            ufoGrabCoroutine = coroutine.create(function() grabHandler("radioactive") end)
            coroutine.resume(ufoGrabCoroutine)
        else
            if ufoGrabCoroutine then
                coroutine.close(ufoGrabCoroutine)
                ufoGrabCoroutine = nil
                for _, part in pairs(paintPlayerParts) do
                    part.Position = Vector3.new(0, -200, 0)
                end
            end
        end
    end
})

GrabTab:AddToggle({
    Name = "Fire Grab",
    Default = false,
    Color = Color3.fromRGB(240, 0, 0),
    Save = true,
    Flag = "FireGrab",
    Callback = function(enabled)
        if enabled then
            fireGrabCoroutine = coroutine.create(fireGrab)
            coroutine.resume(fireGrabCoroutine)
        else
            if fireGrabCoroutine then
                coroutine.close(fireGrabCoroutine)
                fireGrabCoroutine = nil
            end
        end
    end
})

GrabTab:AddToggle({
    Name = "No-clip Grab",
    Default = false,
    Color = Color3.fromRGB(240, 0, 0),
    Save = true,
    Flag = "NoclipGrab",
    Callback = function(enabled)
        if enabled then
            noclipGrabCoroutine = coroutine.create(noclipGrab)
            coroutine.resume(noclipGrabCoroutine)
        else
            if noclipGrabCoroutine then
                coroutine.close(noclipGrabCoroutine)
                noclipGrabCoroutine = nil
            end
        end
    end
})


local PlayerTab = Window:MakeTab({
    Name = "Player",
    Icon = "rbxassetid://18719810809"
})

WalkSpeedEnabled = false
WalkSpeedValue = 5

WalkSpeedToggle = PlayerTab:AddToggle({
   Name = "Walk Speed Toggle",
   Default = false,
   Callback = function(Value)
       WalkSpeedEnabled = Value
       while WalkSpeedEnabled do
           local Character = game.Players.LocalPlayer.Character
           if Character and Character:FindFirstChild("Humanoid") and Character:FindFirstChild("HumanoidRootPart") then
               Character.HumanoidRootPart.CFrame = Character.HumanoidRootPart.CFrame + Character.Humanoid.MoveDirection * (WalkSpeedValue / 10)
           end
           task.wait()
       end
       if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
           game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
       end
   end
})

PlayerTab:AddSlider({
   Name = "Walk Speed Sliders",
   Min = 50,
   Max = 500,
   Default = 50,
   Color = Color3.fromRGB(255,255,255),
   Increment = 10,
   ValueName = "Speed",
   Callback = function(Value)
       WalkSpeedValue = Value
   end    
})

local player = game.Players.LocalPlayer
local jumpPower = 24
local loopJump = false

local function setJumpPower(power)
    if player and player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.JumpPower = power
    end
end

local function startLoopJump()
    while loopJump do
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            setJumpPower(jumpPower)
        end
        wait()
    end
end

player.CharacterAdded:Connect(function(character)
    wait()
    if loopJump then
        setJumpPower(jumpPower)
        startLoopJump()
    end
end)

PlayerTab:AddToggle({
    Name = "Jump Power Toggle",
    Default = false,
    Callback = function(Value)
        loopJump = Value
        if loopJump then
            setJumpPower(jumpPower)
            startLoopJump()
        else
            setJumpPower(24)
        end
    end
})

PlayerTab:AddSlider({
    Name = "Jump Power Sliders",
    Min = 24,
    Max = 500,
    Default = 24,
    Increment = 10,
    ValueName = "Power",
    Callback = function(Value)
        jumpPower = Value
        if loopJump then
            setJumpPower(jumpPower)
        end
    end
})

setJumpPower(jumpPower)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local infiniteJumpEnabled = false

local function setInfiniteJumpEnabled(value)
    infiniteJumpEnabled = value
end

UserInputService.JumpRequest:Connect(function()
    if infiniteJumpEnabled and humanoid then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)

PlayerTab:AddToggle({
    Name = "Infinite Jump",
    Default = false,
    Callback = function(Value)
        setInfiniteJumpEnabled(Value)
        if Value then
            print("Infinite Jump enabled")
        else
            print("Infinite Jump disabled")
        end
    end
})

PlayerTab:AddSection({ Name = "Spin Character" })

local spinning = false

local function startSpinning()
    while spinning do
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = char.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(1000), 0)
        end
        task.wait(0.1)
    end
end

PlayerTab:AddToggle({
    Name = "Spin Character",
    Default = false,
    Callback = function(Value)
        spinning = Value
        if spinning then
            task.spawn(startSpinning)
        end
    end
})

localPlayer.CharacterAdded:Connect(function()
    if spinning then
        task.spawn(startSpinning)
    end
end)

local Section = PlayerTab:AddSection({
	Name = "Blobman Functions"
})

local loopActive = false
local teleportLoopActive = false
local seatLoopActive = false


local function startLoops()
    loopActive = true
    local player = game.Players.LocalPlayer
    local spawnedInToys = workspace:FindFirstChild(player.Name .. "SpawnedInToys")

    if not spawnedInToys then
        warn("SpawnedInToys não encontrado.")
        return
    end

    local creatureBlobman = spawnedInToys:WaitForChild("CreatureBlobman")
    local blobmanSeat = creatureBlobman:WaitForChild("VehicleSeat")
    local proximityPrompt = blobmanSeat:WaitForChild("ProximityPrompt")

    while loopActive do
        wait() 

        
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.CFrame = blobmanSeat.CFrame
        end

        
        if proximityPrompt.Enabled then
            
            proximityPrompt:InputHoldBegin(nil)
            wait()
            proximityPrompt:InputHoldEnd(nil)
        end


        if not player or not player.Parent then
            break
        end
    end
end


local function stopLoops()
    loopActive = false
end


PlayerTab:AddToggle({
    Name = "Loop Seat On Blobman",
    Default = false,
    Callback = function(Value)
        if Value then
            startLoops()
        else
            stopLoops()
        end
    end    
})


local player = game.Players.LocalPlayer
local spawnedInToys = workspace:FindFirstChild(player.Name .. "SpawnedInToys")

if not spawnedInToys then
    OrionLib:MakeNotification({
        Name = "Erro!",
        Content = "SpawnedInToys não encontrado!",
        Image = "rbxassetid://4483345998",
        Time = 5
    })
    return
end

local trackedBlobmans = {}

local function trackBlobmans()
    for _, toy in ipairs(spawnedInToys:GetChildren()) do
        if toy.Name == "CreatureBlobman" and not trackedBlobmans[toy] then
            local grabbableHitbox = toy:FindFirstChild("GrabbableHitbox")
            if grabbableHitbox then
                trackedBlobmans[toy] = grabbableHitbox
                print("Novo Blobman detectado!")
            end
        end
    end
end

task.spawn(function()
    while true do
        trackBlobmans()
        task.wait(0.5)
    end
end)

PlayerTab:AddToggle({
    Name = "Freeze Blobman",
    Default = false,  
    Callback = function(value)
        for _, grabbableHitbox in pairs(trackedBlobmans) do
            grabbableHitbox.Anchored = value
        end

        OrionLib:MakeNotification({
            Name = "Updated Anchor",
            Content = "The anchor was " .. (value and "enabled" or "disabled") .. " for all Blobmans.",
            Image = "rbxassetid://4483345998",
            Time = 5
        })
        print("Anchor " .. (value and "enabled" or "disabled") .. " for all Blobmans")
    end    
})








local MiscTab = Window:MakeTab({
    Name = "Misc",
	Icon = "rbxassetid://7734058894",
    PremiumOnly = false
})

MiscTab:AddSlider({
    Name = "Reach Silent Aim",
    Min = 0,
    Max = 50,
    Default = 30,
    Callback = function(Value)
        dist = Value
    end
})

MiscTab:AddToggle({
    Name = "Silent Aim",
    Default = false,
    Callback = function(Value)
        SIL = Value
    end
})

STS()

local function acl()

local function ResetVariables()
    local localPlayer = PS.LocalPlayer
    if localPlayer then
        local localChar = localPlayer.Character
        if localChar then
            HR = localChar:FindFirstChild("HumanoidRootPart")
            hum = localChar:FindFirstChild("Humanoid")
        end
    end
end

local function AntiRay(position)
    if position and downDir and raycastParams then
        local data = W:Raycast(position + Vector3.new(0, 3, 0), downDir * 15000, raycastParams)
        if data and data.Instance and data.Instance:IsA("BasePart") and data.Position then
            return true
        else
            return false
        end
    end
end

local function Ray(HR, hum)
    if hum and hum.Health > 0 and HR and HR.Position and downDir and raycastParams then
        return W:Raycast(HR.Position, downDir * 15000, raycastParams)
    end
end

local function onCharacterAdded(character)
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {character}
end

local function SaveD(HR, hum)
    local data = Ray(HR, hum)
    if data and data.Instance and data.Instance:IsA("BasePart") and data.Position then
        lastH = data.Position
    elseif lastH and not freeze and AntiRay(lastH) then
        SE:FireServer(localPlayer)
        HR.AssemblyLinearVelocity = Vector3.new()
        HR.CFrame = CFrame.new(lastH + offPos)
    elseif lastH and freeze and AntiRay(lastH) then
        SE:FireServer(localPlayer)
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
        bodyVelocity.Parent = HR
        wait(frt)
        bodyVelocity:Destroy()
        HR.AssemblyLinearVelocity = Vector3.new()
        HR.CFrame = CFrame.new(lastH + offPos)
    elseif lastH and not freeze and not AntiRay(lastH) and not bodyVelocity then
        SE:FireServer(localPlayer)
        HR.AssemblyLinearVelocity = Vector3.new()
        HR.CFrame = CFrame.new(Vector3.new(0, 0, 0) + offPos)
    elseif lastH and freeze and not AntiRay(lastH) and not bodyVelocity then
        SE:FireServer(localPlayer)
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
        bodyVelocity.Parent = HR
        wait(frt)
        bodyVelocity:Destroy()
        HR.AssemblyLinearVelocity = Vector3.new()
        HR.CFrame = CFrame.new(Vector3.new(0, 0, 0) + offPos)
    end
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)
onCharacterAdded(localChar)

R.Heartbeat:Connect(function()
    if autocl then
        ResetVariables()
        SaveD(HR, hum)
    end
end)
end

local Section = MiscTab:AddSection({
	Name = "Fire And Radgoll"
})

MiscTab:AddToggle({
    Name = "Fire All",
    Default = false,
    Save = true,
    Callback = function(enabled)
        if enabled then
            fireAllCoroutine = coroutine.create(fireAll)
            coroutine.resume(fireAllCoroutine)
        else
            if fireAllCoroutine then
                coroutine.close(fireAllCoroutine)
                fireAllCoroutine = nil
            end
        end
    end
})


MiscTab:AddToggle({
    Name = "Ragdoll All",
    Default = false,
    Save = true,
    Callback = function(enabled)
        if enabled then
            ragdollAllCoroutine = coroutine.create(ragdollAll)
            coroutine.resume(ragdollAllCoroutine)
        else
            if ragdollAllCoroutine then
                coroutine.close(ragdollAllCoroutine)
                ragdollAllCoroutine = nil
            end
        end
    end
})

local Section = MiscTab:AddSection({
	Name = "Bring All"
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SetNetworkOwner = ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("SetNetworkOwner")
local localPlayer = Players.LocalPlayer


local killAuraActive = false
local killAuraCoroutine 
local teleportPosition = Vector3.new(350.7272644042969, -7.35040283203125, -101.56575775146484) 

local function activateKillAura()
    while killAuraActive do
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= localPlayer and player.Character then
                local torso = player.Character:FindFirstChild("Torso") or player.Character:FindFirstChild("HumanoidRootPart")
                if torso then
                    local distance = (localPlayer.Character.HumanoidRootPart.Position - torso.Position).Magnitude
                    if distance <= 20 then 
                        if torso.Position ~= teleportPosition then
                           
                            SetNetworkOwner:FireServer(torso, localPlayer.Character.HumanoidRootPart.CFrame)
                            player.Character:SetPrimaryPartCFrame(CFrame.new(teleportPosition))

                            SetNetworkOwner:FireServer(torso, localPlayer.Character.HumanoidRootPart.CFrame)
                            player.Character:SetPrimaryPartCFrame(CFrame.new(teleportPosition))

                            SetNetworkOwner:FireServer(torso, localPlayer.Character.HumanoidRootPart.CFrame)

                            player.Character:SetPrimaryPartCFrame(CFrame.new(teleportPosition))
                        end
                        wait() 
                    end
                end
            end
        end
        wait() 
    end
end

MiscTab:AddToggle({
    Name = "Bring Players",
    Default = false,
    Callback = function(enabled)
        killAuraActive = enabled 
        if enabled then
            if not killAuraCoroutine then
                killAuraCoroutine = coroutine.create(activateKillAura) 
                coroutine.resume(killAuraCoroutine) 
            end
        else
            killAuraActive = false 
            killAuraCoroutine = nil 
        end
    end
})

MiscTab:AddButton({
    Name = "Set Teleport Position",
    Callback = function()
        teleportPosition = localPlayer.Character.HumanoidRootPart.Position 
        print("Teleport position set to:", teleportPosition)
    end    
})

local tweenService = game:GetService('TweenService')
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear)
local teleportActive = false
local teleportDelay = 2
local originalPosition = nil

local function teleport(position)
    if localPlayer.Character and localPlayer.Character:FindFirstChild('HumanoidRootPart') then
        localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(position)
    end
end

local function teleportToAllPlayers()
    local processedPlayers = {}  
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            local otherHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if otherHumanoidRootPart then
                local playerId = player.UserId  
                if not processedPlayers[playerId] then
                    teleport(otherHumanoidRootPart.Position)
                    SetNetworkOwner:FireServer(otherHumanoidRootPart, localPlayer.Character.HumanoidRootPart.CFrame)
                    processedPlayers[playerId] = true
                    wait(teleportDelay)
                end
            end
        end
    end
end

local function saveOriginalPosition()
    if localPlayer.Character and localPlayer.Character:FindFirstChild('HumanoidRootPart') then
        originalPosition = localPlayer.Character.HumanoidRootPart.Position
    end
end

local function restoreOriginalPosition()
    if originalPosition then
        teleport(originalPosition)
    end
end


MiscTab:AddSlider({
    Name = "Teleport speed",
    Min = 0,
    Max = 4,
    Default = 0.5,
    Increment = 0.1,
    ValueName = "segundos",
    Callback = function(Value)
        teleportDelay = Value
        print("Wait time set for: " .. Value .. " segundos")
    end    
})

MiscTab:AddToggle({
    Name = "Enable To Teleport All",
    Default = false,
    Callback = function(Value)
        teleportActive = Value
        if teleportActive then
            saveOriginalPosition()
            print("Teleport All Players activated!")
            while teleportActive do
                teleportToAllPlayers()
                wait(2)
            end
        else
            restoreOriginalPosition()
            print("Teleport All Players disabled!")
            teleport(teleportPosition)
        end
    end    
})

local antiTab = Window:MakeTab({
	Name = "Anti Defense ✓",
	Icon = "rbxassetid://7734058345",
	PremiumOnly = false
})

antiTab:AddButton({
	Name = "Anti-Grab and Anti-Blob",
	Callback = function()
local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/ionlyusegithubformcmods/1-Line-Scripts/main/Mobile%20Friendly%20Orion')))() 

local Window = OrionLib:MakeWindow({Name = "Anti Grab And Anti Blob", HidePremium = false, SaveConfig = true, ConfigFolder = "OrionTest"})

local antiTab = Window:MakeTab({
	Name = "Anti-Grab And Anti-Blob",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})

_G.toggleActiveAntiGrabAndBlobman = false
_G.autoStruggleCoroutine = nil
_G.initialPosition = nil
_G.teleportDistanceThreshold = 10
_G.velocityThreshold = 1000
_G.grabDistanceThreshold = 10
_G.connections = {}
_G.antiKillEnabled = false
_G.blobmanLoop = nil
_G.whitelistedPlayers = {
    "MaybeFlashh",
}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CharacterEvents = ReplicatedStorage:WaitForChild("CharacterEvents")
local Struggle = CharacterEvents:WaitForChild("Struggle")
local localPlayer = Players.LocalPlayer
local BeingHeld = localPlayer:WaitForChild("IsHeld")

local function isWhitelisted(playerName)
    for _, name in ipairs(_G.whitelistedPlayers) do
        if name == playerName then
            return true
        end
    end
    return false
end

local function disconnectAll()
    for _, connection in pairs(_G.connections) do
        if connection then
            connection:Disconnect()
        end
    end
    _G.connections = {}
end


local function removeAllBlobmans()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            local otherSpawnedInToys = workspace:FindFirstChild(player.Name .. "SpawnedInToys")
            if otherSpawnedInToys then
                for _, blobman in ipairs(otherSpawnedInToys:GetChildren()) do
                    if blobman:IsA("Model") and blobman.Name == "CreatureBlobman" then
                        blobman:Destroy()
                    end
                end
            end
        end
    end
end


local function monitorBlobmans()
    if _G.blobmanLoop then
        _G.blobmanLoop:Disconnect()
    end

    _G.blobmanLoop = RunService.Heartbeat:Connect(function()

        removeAllBlobmans()
    end)
end

local function stopMonitoringBlobmans()
    if _G.blobmanLoop then
        _G.blobmanLoop:Disconnect()
        _G.blobmanLoop = nil
    end
end

local function setupSitAndRemoveCreatureBlobman()
    removeAllBlobmans()
    monitorBlobmans()
end

local function startAutoStruggle()
    _G.autoStruggleCoroutine = RunService.Heartbeat:Connect(function()
        local character = localPlayer.Character
        if character and character:FindFirstChild("Head") then
            local partOwner = character.Head:FindFirstChild("PartOwner")
            if partOwner and not isWhitelisted(partOwner.Value) then
                Struggle:FireServer()
                for _, part in pairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.Anchored = true
                    end
                end
                while BeingHeld.Value do
                    RunService.Heartbeat:Wait()
                end
                for _, part in pairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.Anchored = false
                    end
                end
            end
        end
    end)
end

local function teleportToInitialPosition()
    if _G.toggleActiveAntiGrabAndBlobman and _G.initialPosition then
        local char = localPlayer.Character
        local humanoidRootPart = char and char:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            humanoidRootPart.CFrame = CFrame.new(_G.initialPosition)
        end
    end
end

local function onThrow()
    if _G.toggleActiveAntiGrabAndBlobman then
        local char = localPlayer.Character
        local humanoidRootPart = char and char:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            local currentVelocity = humanoidRootPart.AssemblyLinearVelocity
            local distanceFromStart = (humanoidRootPart.Position - _G.initialPosition).Magnitude
            if currentVelocity.Magnitude > _G.velocityThreshold and distanceFromStart > _G.teleportDistanceThreshold then
                humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                teleportToInitialPosition()
            end
        end
    end
end

table.insert(_G.connections, RunService.RenderStepped:Connect(onThrow))

BeingHeld.Changed:Connect(function(isHeld)
    if _G.toggleActiveAntiGrabAndBlobman and isHeld then
        local char = localPlayer.Character
        local humanoidRootPart = char and char:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            _G.initialPosition = humanoidRootPart.Position
            local eventConnection
            eventConnection = RunService.RenderStepped:Connect(function()
                if BeingHeld.Value then
                    local partOwner = char.Head:FindFirstChild("PartOwner")
                    if partOwner and not isWhitelisted(partOwner.Value) then
                        local distanceMoved = (humanoidRootPart.Position - _G.initialPosition).Magnitude
                        if distanceMoved > _G.grabDistanceThreshold then
                            humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                            humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                            Struggle:FireServer(localPlayer)
                        end
                    end
                else
                    eventConnection:Disconnect()
                end
            end)
            table.insert(_G.connections, eventConnection)
        end
    end
end)

local function antiKill()
    if _G.antiKillEnabled then
        local char = localPlayer.Character
        local humanoid = char and char:FindFirstChild("Humanoid")
        if humanoid and not isWhitelisted(localPlayer.Name) then
            humanoid.Health = math.huge
            humanoid.MaxHealth = math.huge
        end
    end
end

table.insert(_G.connections, RunService.Stepped:Connect(antiKill))

local function onHealthChanged()
    if _G.antiKillEnabled then
        local char = localPlayer.Character
        local humanoid = char and char:FindFirstChild("Humanoid")
        if humanoid and not isWhitelisted(localPlayer.Name) then
            humanoid.HealthChanged:Connect(function(newHealth)
                if newHealth < humanoid.MaxHealth then
                    humanoid.Health = humanoid.MaxHealth
                end
            end)
        end
    end
end

localPlayer.CharacterAdded:Connect(onHealthChanged)
if localPlayer.Character then
    onHealthChanged()
end

local function disableMassless()
    local function updateMassless()
        local character = localPlayer.Character
        if character then
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.Massless = false
                end
            end
        end
    end
    
    if not masslessLoop then
        masslessLoop = RunService.Heartbeat:Connect(function()
            updateMassless()
            if not localPlayer.Character or not localPlayer.Character:FindFirstChild("Humanoid") then
                masslessLoop:Disconnect()
                masslessLoop = nil
            end
        end)
    end
    
    updateMassless()
end

local function stopMassless()
    if masslessLoop then
        masslessLoop:Disconnect()
        masslessLoop = nil
    end
end

antiTab:AddToggle({
    Name = "Anti-Grab-Blob",
    Default = false,
    Save = true,
    Flag = "AutoStruggle",
    Callback = function(enabled)
        _G.toggleActiveAntiGrabAndBlobman = enabled
        _G.antiKillEnabled = enabled
        if enabled then
            startAutoStruggle()
            setupSitAndRemoveCreatureBlobman()
            disableMassless()
        else
            if _G.autoStruggleCoroutine then
                _G.autoStruggleCoroutine:Disconnect()
                _G.autoStruggleCoroutine = nil
            end
            disconnectAll()
            stopMonitoringBlobmans()
            stopMassless()  
        end
    end
})

PS64 = game:GetService("Players")
RS64 = game:GetService("ReplicatedStorage")
R64 = game:GetService("RunService")
WS64 = game:GetService("Workspace")
LocalPlayer64 = PS64.LocalPlayer

CHECK_INTERVAL64 = 1
notificationSent64 = false
detectingBlobman = false
masslessLoopActive = false
antiGrabActive = false
protectionsEnabled = false

function sendNotification64()
    if notificationSent64 then return end
    notificationSent64 = true
    local sound64 = Instance.new("Sound", game.SoundService)
    sound64.SoundId = "rbxassetid://6807091537"
    sound64.Volume = 2
    sound64.Looped = false
    sound64:Play()
    OrionLib:MakeNotification({
        Name = "Anti-Blob Active!",
        Content = "All protections are ON. You are now safe from grabs and blob detectors.",
        Image = "rbxassetid://4483345998",
        Time = 5
    })

    sound64.Ended:Connect(function()
        OrionLib:MakeNotification({
            Name = "Okay...",
            Content = "19 Dollar Fortnite Card! Saved You hehe with anti blobby",
            Image = "rbxassetid://4483345998",
            Time = 5
        })
        sound64:Destroy()
    end)
end

function disableExplosions64()
    WS64.DescendantAdded:Connect(function(v64)
        if v64:IsA("Explosion") then
            v64.BlastPressure = 0
        end
    end)
end

function setupAntiGrab64()
    task.spawn(function()
        while antiGrabActive do
            local char64 = LocalPlayer64.Character
            if char64 and char64:FindFirstChild("HumanoidRootPart") then
                local isGrabbedByDetector = false
                for _, player64 in ipairs(PS64:GetPlayers()) do
                    if player64 ~= LocalPlayer64 then
                        local blobmanFolder64 = WS64:FindFirstChild(player64.Name .. "SpawnedInToys")
                        if blobmanFolder64 then
                            for _, blobman64 in ipairs(blobmanFolder64:GetChildren()) do
                                if blobman64.Name == "CreatureBlobman" then
                                    for _, descendant64 in ipairs(blobman64:GetDescendants()) do
                                        if descendant64:IsA("BasePart") and (descendant64.Name == "RightDetector" or descendant64.Name == "LeftDetector") then
                                            if descendant64:FindFirstChild("AttachPlayer") and descendant64.AttachPlayer.Value == LocalPlayer64 then
                                                isGrabbedByDetector = true
                                                break
                                            end
                                        end
                                    end
                                end
                                if isGrabbedByDetector then break end
                            end
                        end
                        if isGrabbedByDetector then break end
                    end
                end

                if isGrabbedByDetector then
                    char64["HumanoidRootPart"].Anchored = true
                    char64["HumanoidRootPart"].AssemblyLinearVelocity = Vector3.new()
                else
                    char64["HumanoidRootPart"].Anchored = false
                end
            end
            task.wait(0.2)
        end
    end)
end

function neutralizeDetectors64(blobman64)
    for _, descendant64 in ipairs(blobman64:GetDescendants()) do
        if descendant64:IsA("BasePart") and (descendant64.Name == "RightDetector" or descendant64.Name == "LeftDetector") then
            if descendant64:FindFirstChild("AttachPlayer") then
                descendant64.AttachPlayer:Destroy()
            end
            descendant64.CanTouch = false
            descendant64.CanCollide = false
        end
    end
end

function detectAndNeutralizeDetectors64()
    task.spawn(function()
        while detectingBlobman do
            for _, player64 in ipairs(PS64:GetPlayers()) do
                if player64 ~= LocalPlayer64 then 
                    local blobmanFolder64 = WS64:FindFirstChild(player64.Name .. "SpawnedInToys")
                    if blobmanFolder64 then
                        for _, blobman64 in ipairs(blobmanFolder64:GetChildren()) do
                            if blobman64.Name == "CreatureBlobman" then
                                neutralizeDetectors64(blobman64)
                            end
                        end
                    end
                end
            end
            local plots64 = { "Plot1", "Plot2", "Plot3", "Plot4", "Plot5" }
            for _, plotName64 in ipairs(plots64) do
                local plot64 = WS64.PlotItems:FindFirstChild(plotName64)
                if plot64 then
                    local blobman64 = plot64:FindFirstChild("CreatureBlobman")
                    if blobman64 then
                        neutralizeDetectors64(blobman64)
                    end
                end
            end
            task.wait(CHECK_INTERVAL64)
        end
    end)
end

function setMassless64()
    task.spawn(function()
        while masslessLoopActive do
            local char64 = LocalPlayer64.Character
            if char64 then
                local parts64 = {
                    char64:FindFirstChild("CamPart"),
                    char64:FindFirstChild("Head"),
                    char64:FindFirstChild("HumanoidRootPart"),
                    char64:FindFirstChild("Left Arm"),
                    char64:FindFirstChild("Left Leg"),
                    char64:FindFirstChild("Right Arm"),
                    char64:FindFirstChild("Right Leg"),
                    char64:FindFirstChild("Torso")
                }
                for _, part64 in ipairs(parts64) do
                    if part64 and part64:IsA("BasePart") then
                        part64.Massless = false
                    end
                end
            end
            task.wait(0.5)
        end
    end)
end

function onCharacterAdded64(char64)
    if protectionsEnabled then
        setupAntiGrab64()
        detectAndNeutralizeDetectors64()
        setMassless64()
    end
end

LocalPlayer64.CharacterAdded:Connect(onCharacterAdded64)
if LocalPlayer64.Character then
    onCharacterAdded64(LocalPlayer64.Character)
end

function activateAllProtections()
    protectionsEnabled = true
    if not notificationSent64 then
        sendNotification64()
    end
    disableExplosions64()
    detectingBlobman = true
    masslessLoopActive = true
    antiGrabActive = true
    setupAntiGrab64()
    detectAndNeutralizeDetectors64()
    setMassless64()
end

function deactivateAllProtections()
    protectionsEnabled = false
    detectingBlobman = false
    masslessLoopActive = false
    antiGrabActive = false
end

antiTab:AddToggle({
    Name = "Anti Blob",
    Default = false,
    Callback = function(Value)
        if Value then
            activateAllProtections()
        else
            deactivateAllProtections()
        end
    end    
})

local Section = antiTab:AddSection({
	Name = "Auto Defense"
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local localPlayer = Players.LocalPlayer

local GrabEvents = ReplicatedStorage:WaitForChild("GrabEvents")
local SetNetworkOwner = GrabEvents:WaitForChild("SetNetworkOwner")

local autoAttackActive = false
local selectedAttack = "Fling"
local currentCoroutine

local function stopCoroutine()
    if currentCoroutine then
        coroutine.close(currentCoroutine)
        currentCoroutine = nil
    end
end

local function setNetwork(target)
    if target then
        SetNetworkOwner:FireServer(target, localPlayer.Character.HumanoidRootPart.CFrame)
    end
end

local function freeze(attacker)
    if attacker.Character then
        local target = attacker.Character:FindFirstChild("HumanoidRootPart")
        if target then
            setNetwork(target)
            local bodyVelocity = target:FindFirstChild("FreezeVelocity") or Instance.new("BodyVelocity")
            bodyVelocity.Name = "FreezeVelocity"
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            bodyVelocity.Parent = target
        end
    end
end

local function fling(attacker)
    if attacker.Character then
        local target = attacker.Character:FindFirstChild("HumanoidRootPart")
        if target then
            setNetwork(target)
            local awayDirection = (target.Position - localPlayer.Character.HumanoidRootPart.Position).Unit
            awayDirection = Vector3.new(awayDirection.X, 0, awayDirection.Z)
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.Velocity = awayDirection * 9999999999999
            bodyVelocity.Parent = target
            Debris:AddItem(bodyVelocity, 0.1)
        end
    end
end

local function kill(attacker)
    if attacker.Character then
        setNetwork(attacker.Character:FindFirstChild("HumanoidRootPart"))
        attacker.Character:BreakJoints()
        local humanoid = attacker.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Health = 0
        end
    end
end

local function void(attacker)
    if attacker.Character then
        local target = attacker.Character:FindFirstChild("HumanoidRootPart")
        if target then
            setNetwork(target)
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
            bodyVelocity.Velocity = Vector3.new(0, -1000, 0)
            bodyVelocity.Parent = target
            Debris:AddItem(bodyVelocity, 100)
            target.CFrame = CFrame.new(Vector3.new(0, -1000, 0))
        end
    end
end

local function spy(attacker)
    if attacker.Character then
        local target = attacker.Character:FindFirstChild("HumanoidRootPart")
        if target then
            setNetwork(target)
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.Velocity = Vector3.new(0, 100, 0)
            bodyVelocity.Parent = target
            Debris:AddItem(bodyVelocity, 0.1)
        end
    end
end

local function autoAttackLoop()
    stopCoroutine()
    currentCoroutine = coroutine.create(function()
        while autoAttackActive do
            local character = localPlayer.Character
            if character and character:FindFirstChild("Head") then
                local partOwner = character.Head:FindFirstChild("PartOwner")
                if partOwner then
                    local attacker = Players:FindFirstChild(partOwner.Value)
                    if attacker then
                        if selectedAttack == "Freeze" then
                            freeze(attacker)
                        elseif selectedAttack == "Fling" then
                            fling(attacker)
                        elseif selectedAttack == "Kill" then
                            kill(attacker)
                        elseif selectedAttack == "Void" then
                            void(attacker)
                        elseif selectedAttack == "Spy" then
                            spy(attacker)
                        end
                    end
                end
            end
            wait(0.02)
        end
    end)
    coroutine.resume(currentCoroutine)
end

local function onDeath()
    if autoAttackActive then
        wait(3)
        autoAttackLoop()
    end
end

local function onSpawn(character)
    character:WaitForChild("Humanoid").Died:Connect(onDeath)
end

if localPlayer.Character then
    onSpawn(localPlayer.Character)
end

localPlayer.CharacterAdded:Connect(onSpawn)

antiTab:AddDropdown({
    Name = "Auto-Attack (Type)",
    Default = "Fling",
    Options = {"Freeze", "Fling", "Death", "Void", "Spy"},
    Callback = function(Value)
        selectedAttack = Value
        if autoAttackActive then
            autoAttackLoop()
        end
    end
})

antiTab:AddToggle({
    Name = "Auto-Attacker",
    Color = Color3.fromRGB(240, 0, 0),
    Default = false,
    Save = true,
    Flag = "AutoAttackEnabled",
    Callback = function(enabled)
        autoAttackActive = enabled
        if enabled then
            autoAttackLoop()
        else
            stopCoroutine()
        end
    end
})



OrionLib:Init()

  	end    
})


antiTab:AddButton({
	Name = "Anti [so as not to bug]",
	Callback = function()
print("start")
_G.heart = "♥"
_G.f2 = "🍇"
function printke()
    local ke = {
        {"", "", " ♥", "", ""," 🍇","🍇","🍇", " ",  "♥", "♥", "♥", "♥", " ", "", "🍇", "🍇", "🍇", "🍇"},
        {"", " ", "♥", " ", "🍇", " ", " ", "🍇 ",    "♥", " ", " ", " ", " ", " ","🍇", " ", " ", " ", " "},
        {"", " ", "♥", " ", "🍇", " ", " ", "🍇",     "♥", "♥", "♥", "♥", " ", " ","🍇", "🍇", "🍇", "🍇", " "},
        {"", " ", "♥", " ", "🍇", " ", " ", "🍇",     " ", " ", " ", "♥", " ", " ","🍇", " ", " ", " ", " "},
        {"♥", "♥", "", " ", "","🍇","🍇","🍇",       "♥", "♥", "♥", "♥", " ", " ", "🍇", "🍇", "🍇", "🍇", " "}
    }
    for _, line in ipairs(ke) do
        print(table.concat(line, " "))
    end
end
printke()
local UserInputService = game:GetService("UserInputService")
local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/ionlyusegithubformcmods/1-Line-Scripts/main/Mobile%20Friendly%20Orion')))() 
--â™¥localsâ™¥
	local S = {
		Players = game:GetService("Players"),
		RS = game:GetService("ReplicatedStorage"),
		RSs = game:GetService("RunService"),
		w = game:GetService("Workspace"),
		r = game:GetService("RunService"),
		d = game:GetService("Debris"),
		HS = game:GetService("HttpService"),
		UIS = game:GetService("UserInputService"),
		StarterGui = game:GetService("StarterGui")}

	local me = S.Players.LocalPlayer; local pccontrol = me.PlayerGui.ControlsGui.PCFrame

	local O = {
		Events = {
			saymsg = S.RS.DefaultChatSystemChatEvents.SayMessageRequest,
			getmsg = S.RS.DefaultChatSystemChatEvents.OnMessageDoneFiltering,
			DestroyToyEvent = S.RS.MenuToys.DestroyToy,
			SetLineColorEvent = S.RS.DataEvents.UpdateLineColorsEvent,
			ExtendLineEvent = S.RS.GrabEvents.ExtendGrabLine,
			CreateGrabEvent = S.RS.GrabEvents.CreateGrabLine,
			StruggleEvent = S.RS.CharacterEvents.Struggle,
			StickyPartEvent = S.RS.PlayerEvents.StickyPartEvent,
			BombEvent = S.RS.BombEvents.BombExplode,
			DestroyGrabLineEvent = S.RS.GrabEvents.DestroyGrabLine,
			SetNetworkOwnerEvent = S.RS.GrabEvents.SetNetworkOwner,
			Ragdoll = S.RS.CharacterEvents.RagdollRemote,
			SpawnToyEvent = S.RS.MenuToys.SpawnToyRemoteFunction},

		me = S.Players.LocalPlayer,
		myname = me.Name,
		mouse = me:GetMouse(),
		BeingHeld = me.IsHeld,
		pccontrol = me.PlayerGui.ControlsGui.PCFrame,
		pccontroltoy = pccontrol.ToyMenu,
		backpack = S.w[me.Name.."SpawnedInToys"],
		m = S.w.Map,
		SL = S.w.SpawnLocation,
		stoys = nil,
		pcld = nil,
		backpacks = nil,
		chars = nil,
		hls = nil,
		ccc = S.w.Camera:FindFirstChild("ColorCorrection"),
		sunrays = nil}

	local N = {
		V = {
			mhv3 = Vector3.new(math.huge, math.huge, math.huge),
			nv3 = Vector3.new(0, 0, 0)},

		C1 = {
			Color3.fromRGB(0,0,0),
			Color3.fromRGB(0,255,0),
			Color3.fromRGB(255,255,0),
			Color3.fromRGB(255,0,0)},

		C2 = {
			Color3.fromRGB(0, 255, 255),
			Color3.fromRGB(0,255,0),
			Color3.fromRGB(127,255,0),
			Color3.fromRGB(255,255,0),
			Color3.fromRGB(255,127,0),
			Color3.fromRGB(255,0,0)},

		distallaura = 24,
		gettimefunc = 0,
		xrta = 0,
		expldelay = 0,
		yrta = 0,
		zrta = 0,
		chal = 0,
		cdyat = 0,
		zoombindv = 0,
		chamsot = 0,
		chamsft = 0,
		RawStep2 = 0,
		step2 = 0,
		hpa = 0,
		dpa = 0,
		cpan = 0,
		cpa = 0,
		hta = 0,
		dta = 0,
		RawStep = 0,
		step = 0,
		cat = 0,
		zgv = 0,
		ks = 10,
		last_UTP = 0,
		strength = 0,
		Lag_Intensity = 0,
		kickcountc = 0,
		wss = 0,
		jps = 0,
		gs = 0,
		linecolorscount = 0,
		debug = 4}

	local L = {
		publicds = false,
		spyenabled = false,
		public = false,
		zoombind = false,
		gluegrab = false,
		controltrain = false,
		hidealltoys = false,
		shadowalltoys = false,
		storeallplayerstoys = false,
		vhsows = true,
		debug = false,
		smptmt = false,
		tptoyfs = false,
		spyallplrinfo = true,
		paitd = false}


	local P = {
		gkblob = nil,
		who = nil,
		lplr = nil,
		rplr = nil,
		whll = nil,
		last_toy = nil,
		last_model = nil,
		last_chto = nil,
		last_chto2 = nil,
		spat = nil,
		tptoypos = CFrame.new(363.534424, -7.35040426, 527.307678, 0.425311029, 3.02851468e-08, -0.905047238, 8.34827762e-09, 1, 3.73856288e-08, 0.905047238, -2.34561064e-08, 0.425311029)}

	local Lt = {
		toys = {
			BombMissile = {"HitboxBodyTop", "PartHitDetector"},
			BombDarkMatter = {"PartHitDetector","Spinner"},
			BallSnowball = {"SoundPart"}},

		gps = {
			BombMissile = "HitboxBodyTop",
			BombDarkMatter = "Spinner",
			BallSnowball = "SoundPart"},

		admins = {959216740, 5516434780, 2311784954, 6192858983, 7427155484},
		lat = {},
		hui = {},
		hui2 = {},
		ggl = {},
		ccolors = {},
		privateProperties = {
			Color = Color3.fromRGB(255,0,0),
			Font = Enum.Font.SourceSansBold,
			TextSize = 18},
		last_urls = {},
		spylist = {},
		sspylist = {},
		ftapcolors = {
			Coins = Color3.fromRGB(0, 0, 0),
			TabBar = Color3.fromRGB(0, 0, 0),
			Settings = Color3.fromRGB(66, 66, 66),
			Shop = Color3.fromRGB(0, 0, 0),
			ToyDestroy = Color3.fromRGB(0, 0, 0),
			ToysShop = Color3.fromRGB(0, 0, 0),
			Toys = Color3.fromRGB(0, 0, 0),
			SettingsContents = Color3.fromRGB(90, 90, 90),
			SettingsTitle = Color3.fromRGB(66, 66, 66),
			ShopTitle = Color3.fromRGB(66, 66, 66),
			ShopContents = Color3.fromRGB(90, 90, 90),
			ToysContents = Color3.fromRGB(90, 90, 90),
			FavoritesFrame = Color3.fromRGB(120, 120, 120),
			Favorites = Color3.fromRGB(66, 66, 66),
			MeterFrame = Color3.fromRGB(120, 120, 120),
			SortingTabs = Color3.fromRGB(120, 120, 120),
			ToysTitle = Color3.fromRGB(66, 66, 66),
			DestroyTitle = Color3.fromRGB(66, 66, 66),
			DestroyContents = Color3.fromRGB(90, 90, 90),
			DestroyMeterFrame = Color3.fromRGB(120, 120, 120),
			ToyShopTitle = Color3.fromRGB(66, 66, 66),
			ToyShopSortingTabs = Color3.fromRGB(120, 120, 120),
			ToyShopContents = Color3.fromRGB(90, 90, 90)}}
	
			local Ld = {
				field = function() print("Field function placeholder") end, 
				ppl = {}, 
				bpl = {}, 
				bplid = {},
				bpltag = {}, 
				ldsp = {}, 
				ldsb = {}, 
				ldsbip = {}, 
				lastb = {},
				lastc = {}, 
				lastd = {}  
			}
			
			
	
	local instance = (_G.chatSpyInstance or 0) + 1
	_G.chatSpyInstance = instance
	local chamsfc = Color3.fromRGB(255,255,255)
	local chamsoc = Color3.fromRGB(0,0,0)
	local function set_chams_parametr() end
	local function check_prem() end
	local a = 0
	local debugL1
	local chatFrame = O.me.PlayerGui.Chat.Frame
	me, pccontrol, ldsp, ldsb, ldsbip = nil, nil, nil, nil, nil

--â™¥setingsâ™¥
	typingAnimation = Instance.new("Animation")
	typingAnimation.AnimationId = "rbxassetid://18353618958"
	typingAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
	typingTrack = typingAnimator:LoadAnimation(typingAnimation)

	crouchAnimation = Instance.new("Animation")
	crouchAnimation.AnimationId = "rbxassetid://6980229055"
	crouchAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
	crouchTrack = crouchAnimator:LoadAnimation(crouchAnimation)

	throwedAnimation = Instance.new("Animation")
	throwedAnimation.AnimationId = "rbxassetid://7047322890"
	throwedAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
	throwedTrack = throwedAnimator:LoadAnimation(throwedAnimation)


	game.Lighting.FogEnd = 1000000000000
	game.Lighting.Sky.StarCount = 5000
	game.Lighting.ShadowSoftness = 1
	game.Lighting.Sky.SkyboxBk = "rbxassetid://1289067181"
	game.Lighting.Sky.SkyboxDn = "rbxassetid://1289084895"
	game.Lighting.Sky.SkyboxFt = "rbxassetid://1289065660"
	game.Lighting.Sky.SkyboxLf = "rbxassetid://1289065992"
	game.Lighting.Sky.SkyboxRt = "rbxassetid://1289066325"
	game.Lighting.Sky.SkyboxUp = "rbxassetid://1289076870"
	game.Lighting.Sky.SunTextureId = "rbxasset://sky/sun.jpg"
	game.Lighting.Sky.MoonTextureId = "rbxasset://sky/moon.jpg"
	O.sunrays = Instance.new("SunRaysEffect", game.Lighting)
	O.sunrays.Intensity = 0
	O.sunrays.Spread = 0

	O.bloomeffect = Instance.new("BloomEffect", game.Lighting)
	O.bloomeffect.Intensity = 0
	O.bloomeffect.Size = 0
	O.bloomeffect.Threshold = 0

	O.ccc = Instance.new("ColorCorrectionEffect", S.w.Camera)
	O.ccc.Enabled = false

	O.hls = Instance.new("Folder", S.w)
	O.hls.Name = _G.heart.."hls".._G.heart

	O.chars = Instance.new("Folder", S.w)
	O.chars.Name = _G.heart.."chars".._G.heart

	O.backpacks = Instance.new("Folder", S.w)
	O.backpacks.Name = _G.heart.."backpacks".._G.heart

	O.pcld = Instance.new("Folder", S.w)
	O.pcld.Name = _G.heart.."pcld".._G.heart

	O.stoys = Instance.new("Folder", S.w)
	O.stoys.Name = _G.heart.."stoys".._G.heart

	chatFrame.ChatChannelParentFrame.Visible = true
	chatFrame.ChatBarParentFrame.Position = chatFrame.ChatChannelParentFrame.Position+UDim2.new(UDim.new(),chatFrame.ChatChannelParentFrame.Size.Y)
	
	pst = true


	local function if3(a1, a2, a3, b1, b2, b3)
		local t = false
		local l = ""; for _,ll in pairs(a1) do l=l..ll end; a1 = l
		local l = ""; for _,ll in pairs(a2) do l=l..ll end; a2 = l
		local l = ""; for _,ll in pairs(a3) do l=l..ll end; a3 = l
		local l = ""; for _,ll in pairs(b1) do l=l..ll end; b1 = l
		local l = ""; for _,ll in pairs(b2) do l=l..ll end; b2 = l
		local l = ""; for _,ll in pairs(b3) do l=l..ll end; b3 = l
		if if3_help(a1, b2, b3) or a1 ~= b1 then t = true
		elseif if3_help(a2, b1, b3) or a2 ~= b2 then t = true
		elseif if3_help(a3, b1, b2) or a3 ~= b3 then t = true end
		return t
	end



--â™¥funcâ™¥
	local function auto_invis_touch() end
	local function After_AG() end
	local function set_hl() end
	local function get_all12() end
	local function get_plr() end
	local function get_rank() end
	--â™¥notifysâ™¥
		local function fstatus(text)
			Ld.field:Notify({
				Title = "Function Status",
				Content = text,
				Duration = 5,
				Image = 4483362458
			})
		end

		local function dnotify(text, n)
			if L.debug and N.debug == n then
				Ld.field:Notify({
					Title = "Debug",
					Content = text,
					Duration = 5,	
					Image = 4483362458
				})
			end
		end

		local function notify(text)
			Ld.field:Notify({
				Title = "Notify",
				Content = text,
				Duration = 5,	
				Image = 4483362458
			})
		end

		local function notify2(text1, text2)
			Ld.field:Notify({
				Title = text1,
				Content = text2,
				Duration = 5,	
				Image = 4483362458
			})
		end

	--â™¥bestâ™¥
		--â™¥mathâ™¥
			local function magnitude(prt, prt1) return (prt.Position - prt1.Position).Magnitude end
			local function PackColor(Color) return {R = Color.R * 255, G = Color.G * 255, B = Color.B * 255} end
			local function UnpackColor(Color) return Color3.fromRGB(Color.R, Color.G, Color.B) end

		--â™¥checksâ™¥
			local function check_list(list, find) for _,v in pairs(list) do if v == find then return v end end end
			local function check_limbs(prt) return check_list({"Head","Right Arm","Right Leg","Left Arm","Left Leg","Torso","HumanoidRootPart"}, prt.Name) end
			local function check_hum(hum) if hum and hum.Health ~= 0 and hum:GetState() ~= Enum.HumanoidStateType.Dead then return true end end
			local function check_spy(nk) local t = false; t = check_list(Lt.spylist, nk); t = check_list(Lt.sspylist, nk); return t end
			local function check_whll(nk) return not(check_list(P.whll, nk)) end
			local function check_mag1(prt, prt1) if magnitude(prt, prt1) < 25 then return true end end
			local function check_mag2(prt, prt1) if magnitude(prt, prt1) > 25 then return true end end
			local function check_admin(id) return check_list(Lt.admins, id) end
			local function check_plr(obj, t) local hrp, hum, hd, hrp1, hum1, hd1 = get_all12(obj) 
				if hrp and hum and check_hum(hum) and hd and hrp1 and hum1 and check_hum(hum1) and hd1 and not(get_plr(obj).InPlot.Value) then
					if t then t = check_mag1(hrp, hrp1) else t = true end; if t then return hrp, hum, hd, hrp1, hum1, hd1 end end end
			local function check_rank(plr) if get_rank(O.me) > get_rank(plr) then return true end end
			

		--â™¥getsâ™¥
			local function get_time() if N.gettimefunc ~= 0 then print(os.clock() - N.gettimefunc); N.gettimefunc = 0 else N.gettimefunc = os.clock() end end
			local function get_end(list) local endd; for _,v in pairs(list) do endd = v end; return endd end
			local function get_endi(list) local enddi; for i,_ in pairs(list) do enddi = i end; return enddi end
			local function get_rotate(list) local rot = {}; local is = get_endi(list); for i,v in pairs(list) do rot[is-i+1] = v end; return rot end
			local function get_parents(obj) local p = obj; local tree = {obj} while p ~= game do p = p.Parent; table.insert(tree, p) end; return tree end
			local function get_child(obj, tree) local last = obj; for _,obj in ipairs(tree) do if last:FindFirstChild(obj) then last = last[obj] end end return last end
			local function get_char(obj) if obj then for _,plr in ipairs(S.Players:GetPlayers()) do local pf; if obj == plr then return plr.Character end; if plr.Character then pf = check_list(get_parents(obj), plr.Character) end; if pf then return pf end end end end
			function get_plr(obj) local char = get_char(obj); for _,plr in ipairs(S.Players:GetPlayers()) do if plr.Character and plr.Character == char then return plr end end end
			local function get_char_child(obj, obj1) local char = get_char(obj); if char and char:FindFirstChild(obj1) then return char[obj1] end end
			local function get_mychar_child(obj) local char = O.me.Character; if char and char:FindFirstChild(obj) then return char[obj] end end
			local function get_hrp() return get_mychar_child("HumanoidRootPart") end
			local function get_hum() return get_mychar_child("Humanoid") end
			local function get_hd() return get_mychar_child("Head") end
			local function get_hrp1(obj) return get_char_child(obj, "HumanoidRootPart") end
			local function get_hum1(obj) return get_char_child(obj, "Humanoid") end
			local function get_hd1(obj) return get_char_child(obj, "Head") end
			local function get_all() return get_hrp(), get_hum(), get_hd() end
			local function get_all1(obj) return get_hrp1(obj), get_hum1(obj), get_hd1(obj) end
			function get_all12(obj) return get_hrp(), get_hum(), get_hd(), get_hrp1(obj), get_hum1(obj), get_hd1(obj) end
			local function get_grabprt(toy) for _,prt in pairs(toy:GetChildren()) do if (prt:IsA("Part") or prt:IsA("MeshPart")) and prt.CanQuery and prt.CanCollide then return prt end end end
			local function get_po(toy) for _,prt in pairs(toy:GetChildren()) do if prt:FindFirstChild("PartOwner") then return prt.PartOwner end end end
			function get_rank(plr) local rank = 0; if not(check_prem(plr.Name)) then rank = 1 end; if check_admin(plr.UserId) then rank = 2 end; if plr == O.me and L.vhsows then rank = 3 end; return rank end

		--â™¥convsâ™¥
			local function con_LtoS(list) local str = ""; for _,v in pairs(list) do str = str..v end; return str end
			local function con_TtoS(list) local list1 = get_rotate(list); local str = ""; for i,v in pairs(list1) do if i ~= get_endi(list1) then str = str..tostring(v).."." end end; str = str..tostring(get_end(list1)); return str end

		--â™¥eventsâ™¥
			local function invis_touch(a) O.Events.SetNetworkOwnerEvent:FireServer(a,a.CFrame) end
			local function toy_spawn(ToyName,CFrame) O.Events.SpawnToyEvent:InvokeServer(ToyName, CFrame, Vector3.new(0,0,0)) end
			local function toy_spawn1(ToyName) local hd = get_mychar_child("Head") toy_spawn(ToyName, hd.CFrame) end
			local function toy_spawn2(ToyName) local cf = get_mychar_child("HumanoidRootPart").CFrame; toy_spawn(ToyName, cf-Vector3.new(cf.LookVector.X*20, -15, cf.LookVector.Z*20)) end
			local function toy_delete(toy) O.Events.DestroyToyEvent:FireServer(toy) end
			local function toy_explode(BombPHT,PosPart,Pos) local data = {{["Hitbox"] =  BombPHT,["PositionPart"] = PosPart},Pos}; O.Events.BombEvent:FireServer(unpack(data)) end

		--â™¥createsâ™¥
			local function create_blv(parent, name, value) local bv = Instance.new("BoolValue", parent); bv.Value = value; bv.Name = name ; return bv end
			local function create_ov(parent, name, value) local ov = Instance.new("ObjectValue", parent); ov.Value = value; ov.Name = name ; return ov end
			local function create_sv(parent, name, value) local sv = Instance.new("StringValue", parent); sv.Value = value; sv.Name = name ; return sv end
			local function create_bp(parent, name, pos, maxf, d) local bp = Instance.new("BodyPosition", parent)
				bp.Name = name; bp.MaxForce = maxf; bp.D = d; if pos then bp.Position = pos end; return bp end
			local function create_bp1(parent, name, pos) return create_bp(parent, name, pos, N.V.mhv3, 100) end
			local function create_bg(parent, name, maxt, d, cframe) local bg = Instance.new("BodyGyro", parent)
				bg.Name = name; bg.MaxTorque = maxt; bg.D = d; if cframe then bg.CFrame = cframe end return bg end
			local function create_hl(parent, adr, name, ot, ft, oc, fc) local hl = Instance.new("Highlight", parent); hl.Name = name
				hl.OutlineTransparency = ot; hl.FillTransparency = ft; hl.OutlineColor = oc; hl.FillColor = fc; hl.Adornee = adr; return hl end
			local function create_bv(parent, name, vl, maxf) local vel = Instance.new("BodyVelocity", parent);
				vel.Name = name; vel.Velocity = vl; vel.MaxForce = maxf; return vel end

		--â™¥waitsâ™¥
			local function wait_load(parent, name) while not(parent:FindFirstChild(name)) do task.wait() end; return parent[name] end
			local function wait_load1(parent, tree) for i,name in pairs(tree) do tree[i] = wait_load(parent, name); parent = tree[i] end return unpack(tree) end
			local function wait_load2(parent, tree) for _,name in pairs(tree) do parent = wait_load(parent, name) end; return parent end
			local function wait_load11(parent, childs) for i,name in pairs(childs) do childs[i] = wait_load(parent, name) end; return unpack(childs) end
			local function wait_tload(toy, name) if Lt.toys[name] then return wait_load11(toy, Lt.toys[name]) end end
			local function wait_gpload(toy, name) if Lt.gps[name] then return wait_load(toy, Lt.gps[name]) else return get_grabprt(toy) end end


	--â™¥plrsâ™¥
		local function plr_kill1(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp then
				auto_invis_touch(hd1, hrp)
				invis_touch(hd1)
				for a=1, 100 do
					hrp1.CFrame = hrp1.CFrame + Vector3.new(0, -1000, 0)
					task.wait(0.1)
				end
			end
		end

		local function plr_kill2(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp then
				auto_invis_touch(hd1, hrp)
				hum1.Health = 0
			end
		end

		local function plr_fling(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp then
				auto_invis_touch(hd1, hrp)
				if not(hrp1:FindFirstChild("pfbv")) then
					local bv = Instance.new("BodyVelocity", hrp1)
					bv.MaxForce = N.V.mhv3
					bv.Name = "pfbv"
					bv.Velocity = Vector3.new(0, math.huge, 0)
					local con = hd1.PartOwner.AncestryChanged:Connect(function()
						bv:Destroy()
					end)
				end
			end
		end

		local function plr_grab(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp then auto_invis_touch(hd1, hrp) end
		end

		local function plr_ragdoll(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp then
				auto_invis_touch(hd1, hrp)
				local save = hrp1.Position
				local bp = create_bp1(hrp1, "rgbp", hrp1.Position + Vector3.new(0, 1000, 0)); task.wait(0.1)
				bp.Position = save + Vector3.new(0, -10, 0); task.wait(0.1)
				bp.Position = save; task.wait(0.1)
				bp:Destroy(); task.wait(0.1)
			end
		end

		local function plr_split(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp and not(hd1:FindFirstChild("spited")) then
				create_blv(hd1, "spited", true)
				hrp1.Parent.Torso:Destroy()
			end
		end

	--â™¥invis_touchâ™¥
		function auto_invis_touch(prt, hrp, hl, hldata, bp, bg)
			local bv = prt:FindFirstChild("igrab")
			local po = prt:FindFirstChild("PartOwner")
			local sv = prt:FindFirstChild("whograb")
			local con
			if not(sv) then
				sv = create_sv(prt, "whograb", "")
				con = prt.ChildAdded:Connect(function(obj)
					if obj.Name == "PartOwner" then
						sv.Value = obj.Value
					end
				end)
			end
			local function auto()
				set_hl(hl, "FillColor", hldata, 3)
				local save = hrp.CFrame
				local t = false
				local last_pos = prt.Position
				task.spawn(function()
					while (not(po) or po.Value ~= O.myname) and task.wait(0.1) do
						if not(prt.Parent) or not(hrp.Parent) then break end
						if check_hum(hrp.Parent.Humanoid) and last_pos ~= prt.Position then
							last_pos = prt.Position
						end
					end
				end)
				while (not(po) or po.Value ~= O.myname) and task.wait() do
					if not(prt.Parent) or not(hrp.Parent) then break end
					if check_hum(hrp.Parent.Humanoid) then
						if check_mag2(prt, hrp) then
							set_hl(hl, "FillColor", hldata, 4)
							hrp.CFrame = prt.CFrame + ((prt.Position - last_pos)*O.me:GetNetworkPing()*100)
							t = true
							invis_touch(prt)
						else invis_touch(prt) end
					else set_hl(hl, "FillColor", hldata, 5) end
					po = prt:FindFirstChild("PartOwner")
				end
				if t then hrp.CFrame = save end
				set_hl(hl, "FillColor", hldata, 1)
			end
			if sv.Value ~= O.me.Name then auto() end
			if bv then
				set_hl(hl, "FillColor", hldata, 2)
				while not(prt:FindFirstChild("PartOwner")) do task.wait() end
				bp.MaxForce = N.V.nv3
				bg.MaxTorque = N.V.nv3
				while bv.Parent do task.wait() end
				bp.Position = prt.Position
				bg.CFrame = prt.CFrame
				bp.MaxForce = N.V.mhv3
				bg.MaxTorque = N.V.mhv3
				set_hl(hl, "FillColor", hldata, 1)
			end
		end

		local function char_invis_touch(prt, hrp, hl, hldata, bp, bg) auto_invis_touch(wait_load2(get_char, {"Head"}), hrp, hl, hldata, bp, bg) end

		local function safe_invis_touch(prt, hrp, hl, hldata, bp, bg)
			if prt and hrp and prt:IsA("Part") and prt.CollisionGroup == "Items" then
				if check_limbs(prt.Name) then char_invis_touch(prt, hrp, hl, hldata, bp, bg)
				else
					local po = prt:FindFirstChild("PartOwner")
					local save = hrp.CFrame
					local t = false
					local last_pos = prt.Position
					task.spawn(function()
						while t3 and task.wait(0.1) do
							if not(prt.Parent) or not(hrp.Parent) then break end
							if check_hum(hrp.Parent.Humanoid) and last_pos ~= prt.Position then
								last_pos = prt.Position
							end
						end
					end)
					if (not(po) or po.Value ~= O.myname) then
						while (not(po) or po.Value ~= O.myname) and task.wait() do
							if not(prt.Parent) or not(hrp.Parent) then break end
							if check_hum(hrp.Parent.Humanoid) then
								if check_mag2(prt, hrp) then
									hrp.CFrame = prt.CFrame + ((prt.Position - last_pos)*O.me:GetNetworkPing()*100)
									t = true
								else invis_touch(prt) end
							end
							po = get_po(prt.Parent)
						end
						if t then hrp.CFrame = save end
					end
				end
			end
		end
			
		local function loop_invis_touch(prt)
			local v21 = prt:FindFirstChild("ait")
			if not(v21) then
				v21 = Instance.new("ObjectValue", prt)
				v21.Name = "ait"
				local v22 = Instance.new("Highlight", O.hls)
				v22.FillColor = Color3.fromRGB(255, 0, 255)
				v22.OutlineColor = Color3.fromRGB(255, 0, 0)
				v22.FillTransparency = 0.5
				v22.OutlineTransparency = 0
				v22.Adornee = prt
				v22.Name = "aithl"
				v21.Value = v22
				while task.wait() do
					if not(prt.Parent) or not(v21.Parent) or not(v22.Parent) then break end
					local v1 = O.me.Character; if v1 then
						local v2 = v1:FindFirstChild("HumanoidRootPart"); if v2 then
							if check_mag1(v2, prt) then
								invis_touch(prt)
								local save = v22.FillColor
								v22.FillColor = v22.OutlineColor
								v22.OutlineColor = save
								task.wait()
								invis_touch(prt)
								local save = v22.FillColor
								v22.FillColor = v22.OutlineColor
								v22.OutlineColor = save
							end
						end
					end
				end
			end
		end

		local function freeze(prt, hrp)
			local bp = prt:FindFirstChild("fzbp")
			local bg = prt:FindFirstChild("fzbg")
			local hl = prt:FindFirstChild("fzhl")
			if not(bp and bg and hl) then
				local bp = create_bp1(prt, "fzbp", prt.Position)
				local bg = create_bg(prt, "fzbg", N.V.mhv3, 100, prt.CFrame)
				local hl = create_hl(prt, prt.Parent, "fzhl", 0, 0.5, Color3.fromRGB(0, 0, 255), Color3.fromRGB(0, 255, 255))
				while prt.Parent and bp.Parent and bg.Parent and hl.Parent do auto_invis_touch(prt, hrp, hl, N.C2, bp, bg); task.wait() end
			end
		end

	--â™¥spawnsâ™¥
		local function toy_sspawn(name, funcid)
			local hrp, hum = get_all()
			if hrp and hum and check_hum(hum) and not(O.me.InPlot.Value) then
				while not(O.me.CanSpawnToy.Value) do task.wait() end
				if funcid == 1 then task.spawn(toy_spawn1, name) end
				if funcid == 2 then task.spawn(toy_spawn2, name) end
				local toy = wait_load(O.backpack, name.."/n").Value
				O.backpack[name.."/n"]:Destroy()
				return toy
			end
		end

		local function toy_aspawn(name, funcid, hrp)
			local toy = toy_sspawn(name, funcid)
			auto_invis_touch(wait_gpload(toy, name), hrp)
			return toy
		end

		local function toy_void(prt, hrp)
			prt.Parent.Name = prt.Parent.Name.."/v"
			auto_invis_touch(prt ,hrp); if prt.Parent then
				for _,prt in pairs(prt.Parent:GetChildren()) do
					if prt:IsA("Part") or prt:IsA("MeshPart") then
						prt.CanTouch = false
						prt.CanCollide = false
					end
				end
				create_bp1(prt, "vbv", Vector3.new(0, 1111111, 0))
			end
		end

		local function toy_vspawn(name, funcid)
			local toy = toy_sspawn(name, funcid)
			toy_void(wait_gpload(toy, name), get_hrp())
			return toy
		end

	--â™¥setsâ™¥
		function set_hl(hl, choice, data, choice1)
			if hl and choice and data then
				if choice1 then if hl[choice] ~= data[choice1] then hl[choice] = data[choice1] end
				else if hl[choice] ~= data then hl[choice] = data end end
			end
		end

		local function set_ftap_color()
			local Data = {}
			for i,v in pairs(Lt.ftapcolors) do
				Data[i] = PackColor(v)
			end
			writefile("VHS/FTAPColors.vhs",tostring(S.HS:JSONEncode(Data)))

			local plrgui = O.me.PlayerGui
			local tabs = plrgui.MenuGui.Menu.TabBar.Tabs
			local tbcont = plrgui.MenuGui.Menu.TabContents
			local seting = tbcont.Settings
			local shop = tbcont.Shop
			local tbcont_toys = tbcont.Toys
			local tbcont_toysdestroy = tbcont.ToyDestroy
			local tbcont_toyhop = tbcont.ToyShop

			plrgui.MenuGui.TopRight.CoinsFrame.BackgroundColor3 = Lt.ftapcolors.Coins
			plrgui.MenuGui.Menu.TabBar.BackgroundColor3 = Lt.ftapcolors.TabBar
			tabs.Settings.BackgroundColor3 = Lt.ftapcolors.Settings
			tabs.Shop.BackgroundColor3 = Lt.ftapcolors.Shop
			tabs.ToyDestroy.BackgroundColor3 = Lt.ftapcolors.ToyDestroy
			tabs.ToyShop.BackgroundColor3 = Lt.ftapcolors.ToysShop
			tabs.Toys.BackgroundColor3 = Lt.ftapcolors.Toys
			seting.Contents.BackgroundColor3 = Lt.ftapcolors.SettingsContents
			seting.Title.BackgroundColor3 = Lt.ftapcolors.SettingsTitle
			shop.Title.BackgroundColor3 = Lt.ftapcolors.ShopTitle
			shop.Contents.BackgroundColor3 = Lt.ftapcolors.ShopContents
			tbcont_toys.Contents.BackgroundColor3 = Lt.ftapcolors.ToysContents
			tbcont_toys.FavoritesFrame.BackgroundColor3 = Lt.ftapcolors.FavoritesFrame
			tbcont_toys.FavoritesFrame.Favorites.BackgroundColor3 = Lt.ftapcolors.Favorites
			tbcont_toys.MeterFrame.BackgroundColor3 = Lt.ftapcolors.MeterFrame
			tbcont_toys.SortingTabs.BackgroundColor3 = Lt.ftapcolors.SortingTabs
			tbcont_toys.Title.BackgroundColor3 = Lt.ftapcolors.ToysTitle
			tbcont_toysdestroy.Title.BackgroundColor3 = Lt.ftapcolors.DestroyTitle
			tbcont_toysdestroy.Contents.BackgroundColor3 = Lt.ftapcolors.DestroyContents
			tbcont_toysdestroy.MeterFrame.BackgroundColor3 = Lt.ftapcolors.DestroyMeterFrame
			tbcont_toyhop.Title.BackgroundColor3 = Lt.ftapcolors.ToyShopTitle
			tbcont_toyhop.SortingTabs.BackgroundColor3 = Lt.ftapcolors.ToyShopSortingTabs
			tbcont_toyhop.Contents.BackgroundColor3 = Lt.ftapcolors.ToyShopContents
		end

		local function set_chams_parametr()
			for _,plr in ipairs(S.Players:GetPlayers()) do
				local v1 = plr.Character; if v1 then
					local hl = v1:FindFirstChild("cham")
					if not(hl) then hl = Instance.new("Highlight", v1) end
					hl.Name = plr.Name
					hl.Adornee = v1
					hl.Enabled = chamst
					hl.FillColor = chamsfc
					hl.FillTransparency = N.chamsft
					hl.OutlineColor = chamsoc
					hl.OutlineTransparency = N.chamsot
				end
			end
		end

		local function set_line_color()
			local Data = {}
			for i,v in ipairs(Lt.ccolors) do
				Data[i] = PackColor(v)
			end

			writefile("VHS/LineColor.vhs",tostring(S.HS:JSONEncode(Data)))

			local args = {
				ColorSequenceKeypoint.new(0, Lt.ccolors[1]),
				ColorSequenceKeypoint.new(0.10, Lt.ccolors[2]),
				ColorSequenceKeypoint.new(0.15, Lt.ccolors[3]),
				ColorSequenceKeypoint.new(0.20, Lt.ccolors[4]),
				ColorSequenceKeypoint.new(0.25, Lt.ccolors[5]),
				ColorSequenceKeypoint.new(0.30, Lt.ccolors[6]),
				ColorSequenceKeypoint.new(0.35, Lt.ccolors[7]),
				ColorSequenceKeypoint.new(0.40, Lt.ccolors[8]),
				ColorSequenceKeypoint.new(0.45, Lt.ccolors[9]),
				ColorSequenceKeypoint.new(0.50, Lt.ccolors[10]),
				ColorSequenceKeypoint.new(0.55, Lt.ccolors[11]),
				ColorSequenceKeypoint.new(0.60, Lt.ccolors[12]),
				ColorSequenceKeypoint.new(0.65, Lt.ccolors[13]),
				ColorSequenceKeypoint.new(0.70, Lt.ccolors[14]),
				ColorSequenceKeypoint.new(0.75, Lt.ccolors[15]),
				ColorSequenceKeypoint.new(0.80, Lt.ccolors[16]),
				ColorSequenceKeypoint.new(0.85, Lt.ccolors[17]),
				ColorSequenceKeypoint.new(0.90, Lt.ccolors[18]),
				ColorSequenceKeypoint.new(0.95, Lt.ccolors[19]),
				ColorSequenceKeypoint.new(1, Lt.ccolors[20])
			}
			O.Events.SetLineColorEvent:FireServer(ColorSequence.new(args))
		end

		
		local function update_hui()
			Lt.hui = {}
			Lt.hui2 = {}
			local p = "p"
			if L.vhsows then p = "" end
			for _,plr in ipairs(S.Players:GetPlayers()) do
				if plr ~= O.me then
					if not(check_prem(plr.Name)) then
						if plr:IsFriendsWith(O.me.userId) then
							table.insert(Lt.hui, plr.DisplayName.." ("..plr.Name..") â™¦Friendâ™¦ â™¥Premium Userâ™¥")
							Lt.hui2[plr.Name..p] = plr.DisplayName.." ("..plr.Name..") â™¦Friendâ™¦ â™¥Premium Userâ™¥" 
						else
							table.insert(Lt.hui, plr.DisplayName.." ("..plr.Name..") â™¥Premium Userâ™¥")
							Lt.hui2[plr.Name..p] = plr.DisplayName.." ("..plr.Name..") â™¥Premium Userâ™¥" 
						end
					else
						if plr:IsFriendsWith(O.me.userId) then
							table.insert(Lt.hui, plr.DisplayName.." ("..plr.Name..") â™¦Friendâ™¦")
							Lt.hui2[plr.Name] = plr.DisplayName.." ("..plr.Name..") â™¦Friendâ™¦"
						else
							table.insert(Lt.hui, plr.DisplayName.." ("..plr.Name..")")
							Lt.hui2[plr.Name] = plr.DisplayName.." ("..plr.Name..")"
						end
					end
				end
			end
		end; update_hui()

		local function blob_kick(blob,hrp,rl,v)
			local script = blob:FindFirstChild("BlobmanSeatAndOwnerScript"); if script then
				local detec = blob:FindFirstChild(rl.."Detector")
				local grab = script:FindFirstChild("CreatureGrab")
				local drop = script:FindFirstChild("CreatureDrop")
				if detec and grab and drop then
					if v == 1 then
						grab:FireServer(detec,hrp,detec[rl.."Weld"])
					elseif v == 2 then
						drop:FireServer(detec[rl.."Weld"],hrp)
					elseif v == 12 then
						grab:FireServer(detec,hrp,detec[rl.."Weld"])
						drop:FireServer(detec[rl.."Weld"],hrp)
					end
				end
			end
		end

		local function anch_plr()
			O.me.Character.HumanoidRootPart.Anchored = true
			while O.me.Character["Right Arm"].RagdollLimbPart.CanCollide == true do task.wait() end
			O.me.Character.HumanoidRootPart.Anchored = false
		end

		local function reset_gq()
			for _,obj in pairs(S.w:GetDescendants()) do 
				if obj:IsA("Part") and obj:FindFirstChild("gqcs") then
					obj.CastShadow = obj.gqcs.Value
					obj.gqcs:Destroy()
				end
			end
			for _,obj in pairs(S.w:GetDescendants()) do 
				if obj:IsA("Part") and obj:FindFirstChild("gqs") then
					obj.Shadows = obj.gqs.Value
					obj.gqs:Destroy()
				end
			end
			game.MaterialService.Use2022Materials = false
			game.Lighting.Technology = "Voxel"
			game.Lighting.Ambient = Color3.fromRGB(120, 120, 120)
			game.Lighting.OutdoorAmbient = Color3.fromRGB(200, 200, 200)
			O.sunrays.Intensity = 0
			O.sunrays.Spread = 0
			O.bloomeffect.Intensity = 0
			O.bloomeffect.Size = 0
			O.bloomeffect.Threshold = 0
		end


--â™¥forsâ™¥
	for _,plr in ipairs(S.Players:GetPlayers()) do
		if plr ~= O.me then
			if plr.Character then plr.Character.Parent = O.chars end
			if S.w:FindFirstChild(plr.Name.."SpawnedInToys") and plr ~= O.me then
				create_sv(S.w[plr.Name.."SpawnedInToys"], "plr_name", plr.Name)
				S.w[plr.Name.."SpawnedInToys"].Parent = O.backpacks
			end
			plr.CharacterAdded:Connect(function(char)
				char.Parent = O.chars
				set_chams_parametr()
			end)
			-- if plr ~= O.me and plr.InPlot.Value and check_prem(plr.Name) then
			-- 	task.wait()
			-- 	S.w.PlotItems.PlayersInPlots[plr].Parent = S.w
			-- end
		end
	end

	for _,obj in pairs(S.w:GetChildren()) do
		if obj.Name == "PlayerCharacterLocationDetector" then obj.Parent = O.pcld
		else local check = {"Balloons","Cave","Cubes","Drawers",
				"Farm","Food","Furniture","Glass Boxes","Ladders",
				"Large Animals","Lincoln Planks","Music","NOT New",
				"Other","Pallets","Robloxians","Rollers",_G.f2}
			if check_list(check, obj.Name) then obj.Parent = O.stoys end
		end
	end

	for _,prt in pairs(S.w.Plots:GetDescendants()) do if prt.Name == "PlotBarrier" or prt.Name == "PlotArea" then prt.CanQuery = false; prt.CanCollide = false end end



--â™¥connectâ™¥
	S.Players.PlayerAdded:Connect(function(plr)
		plr.CharacterAdded:Connect(function(char)
			if char ~= O.me.Character then
				char.Parent = O.chars
				-- set_chams_parametr()
			end
		end)
		if paitd then post_info(plr) end
		if check_spy(plr.Name) then notify(plr.Name.." ("..plr.DisplayName..") Joined your server") end
		update_hui()
		while not(S.w:FindFirstChild(plr.Name.."SpawnedInToys")) do task.wait() end
		create_sv(S.w[plr.Name.."SpawnedInToys"], "plr_name", plr.Name)
		S.w[plr.Name.."SpawnedInToys"].Parent = O.backpacks
	end)

	S.Players.PlayerRemoving:Connect(function()
		update_hui()
	end)

	O.backpack.ChildAdded:Connect(function(toy)
		if not(toy:IsA("ObjectValue")) then
			local ov = create_ov(toy.Parent, toy.Name.."/n", toy)
			toy.Destroying:Connect(function() ov:Destroy() end)
			if toyaura and sttta and toy.Name ~= "FireExtinguisher" and toy.Name ~= "NinjaKunai" then
				N.cat = N.cat + 1
				table.insert(Lt.lat,toy)
			end
			P.last_toy = toy
		end
	end)

	S.w.ChildAdded:Connect(function(gp)
		if gp.Name == "GrabParts" then
			local wc = wait_load2(gp, {"GrabPart","WeldConstraint"})
			local prt = wc.Part1
			local bv = create_blv(prt, "igrab", true)
			gp.Destroying:Connect(function() bv:Destroy() end)
		end
	end)

    
	S.w.ChildAdded:Connect(function(pcld)
		if pcld.Name == "PlayerCharacterLocationDetector" then
			task.wait(); pcld.Parent = O.pcld
		end
	end)

	S.UIS.JumpRequest:Connect(function()
		local t = true
		if O.me.Character and t and infj then
			t = false
			O.me.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
			task.wait()
			t = true
		end
	end)

	S.w.ChildAdded:Connect(function(f)
		if f.Name == "GrabParts" and not(kickkk1) and not(kickkk2) then
			N.zgv = 0
			local da = f.DragPart.DragAttach
			while f.Parent and task.wait() do da.Position = S.w.Camera.CFrame.LookVector * N.zgv end
		end
	end)

	S.w.ChildAdded:Connect(function(model)
		if model.Name == "GrabParts" and sila then
			local part_to_impulse = model["GrabPart"]["WeldConstraint"].Part1
			if part_to_impulse then
				local velocityObj = Instance.new("BodyVelocity", part_to_impulse)
				model:GetPropertyChangedSignal("Parent"):Connect(function()
					if not model.Parent then
						if S.UIS:GetLastInputType() == Enum.UserInputType.MouseButton2 then
							velocityObj.MaxForce = N.V.mhv3
							velocityObj.Velocity = S.w.CurrentCamera.CFrame.lookVector * N.strength
							S.d:AddItem(velocityObj, 1)
						elseif S.UIS:GetLastInputType() == Enum.UserInputType.MouseButton1 then
							velocityObj:Destroy()
						else
							velocityObj:Destroy()
						end
					end
				end)
			end
		end
	end)



	S.w.ChildAdded:Connect(function(model)--neon
		if model.Name == "GrabParts" and ultragrabbb then
			S.w.GrabParts.DragPart.Color = Color3.fromRGB(255,0,0)
			S.w.GrabParts.DragPart.Transparency = 0
			S.w.GrabParts.DragPart.Material = "Neon"
			model.DragPart.AlignOrientation.Responsiveness = 200
			model.DragPart.AlignOrientation.MaxTorque = "inf"
			model.DragPart.AlignPosition.MaxAxesForce = Vector3.new("inf","inf","inf")
			model.DragPart.AlignPosition.MaxForce = "inf"
			model.DragPart.AlignPosition.Responsiveness = 200
		end
	end)

	S.w.ChildAdded:Connect(function(model)
		if model.Name == "Part" and O.me.Character and antiexpl then
			local mag = (model.Position - O.me.Character.HumanoidRootPart.Position).Magnitude
			if mag <= 18 then
				anch_plr()
			end
		end
	end)

	S.w.DescendantAdded:Connect(function(toy)
		if toy.Name == "CreatureBlobman" and toy.Parent ~= O.backpack and antiblob then
			task.wait()
			wait_load2(toy, {"LeftDetector","AttachPlayer"}):Destroy()
			wait_load2(toy, {"RightDetector","AttachPlayer"}):Destroy()
		end
	end)

	S.w.PlotItems.Plot1.ChildAdded:Connect(function(toy)
		if toy.Name == "PlantPottedCactus" then
			task.wait()
			toy:Destroy()
		end
	end)

	S.w.PlotItems.Plot2.ChildAdded:Connect(function(toy)
		if toy.Name == "PlantPottedCactus" then
			task.wait()
			toy:Destroy()
		end
	end)

	S.w.PlotItems.Plot3.ChildAdded:Connect(function(toy)
		if toy.Name == "PlantPottedCactus" then
			task.wait()
			toy:Destroy()
		end
	end)

	S.w.PlotItems.Plot4.ChildAdded:Connect(function(toy)
		if toy.Name == "PlantPottedCactus" then
			task.wait()
			toy:Destroy()
		end
	end)

	S.w.PlotItems.Plot5.ChildAdded:Connect(function(toy)
		if toy.Name == "PlantPottedCactus" then
			task.wait()
			toy:Destroy()
		end
	end)

	S.w.PlotItems.PlayersInPlots.ChildAdded:Connect(function(plr)--anti dom
		if plr ~= O.me and check_prem(plr.Name) then
			task.wait()
			plr.Parent = O.chars
		end
	end)

	O.me.CharacterAdded:Connect(function()
		typingAnimation = Instance.new("Animation")
		typingAnimation.AnimationId = "rbxassetid://18353618958"
		typingAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
		typingTrack = typingAnimator:LoadAnimation(typingAnimation)

		crouchAnimation = Instance.new("Animation")
		crouchAnimation.AnimationId = "rbxassetid://6980229055"
		crouchAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
		crouchTrack = crouchAnimator:LoadAnimation(crouchAnimation)

		throwedAnimation = Instance.new("Animation")
		throwedAnimation.AnimationId = "rbxassetid://7047322890"
		throwedAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
		throwedTrack = throwedAnimator:LoadAnimation(throwedAnimation)
	end)

	S.UIS.InputChanged:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseWheel and zgt then
			local v1 = S.w:FindFirstChild("GrabParts"); if v1 then
				if inp.Position.Z == 1 then N.zgv = N.zgv + 3 else N.zgv = N.zgv - 3 end
			else N.zgv = 0 end
		end
	end)

	S.Players.PlayerAdded:Connect(function(p)
		p.Chatted:Connect(function(msg)
			chat_msg(p,msg)
		end)
	end)

local Window = OrionLib:MakeWindow({Name = "Anti Defense", HidePremium = false, SaveConfig = true, ConfigFolder = "OrionTest"})











plr = game.Players.LocalPlayer
cam = workspace.CurrentCamera
mouse = plr:GetMouse()
uis = game:GetService("UserInputService")
inv = workspace:WaitForChild(plr.Name.."SpawnedInToys")
rs = game:GetService("ReplicatedStorage")
rs2 = game:GetService("RunService")
deb = game:GetService("Debris")


flingT = nil
killGrabT = nil
infLineExtendT = nil
antiGrab1T = nil
antiGrab1AnchorT = true
antiBlob1T = nil
antiExplodeT = true
antiLagT = nil
antiStickyT = nil
blobLoopT = nil
walkSpeedT = nil
jumpPowerT = nil
infJumpT = nil
noClipT = nil
floatT = nil
masslessT = nil
blobLoopServerT = nil
blobLoopServerTwoHandT = nil
silentBlobServerT = nil
lagT = nil
pingT = nil
shurikenLagServerT = nil
slideTPT = nil
inspectT = false
inspectInfoT = false
inspectInfoOnT = false
ragdollSpamT = false
permRagdollT = nil
autoGucciT = nil
destroyAutoGucciT = nil
sitJumpT = false
floatUpT = false
floatDownT = false
zoomT = false
spychatT = nil
spySelfT = nil
publicSpyT = nil


strengthV = 1000
lineDistanceV = 0
increaseLineExtendV = 0
walkSpeedV = 16
jumpPowerV = 24
floatY = -3.1
zoomV = 20
linesV = 400
packetsV = 3000
playersInLoop1V = {}
playersInLoop2V = {}


currentHouseS = 0
blobmanInstanceS = nil
currentBlobS = nil
currentInspectS = 0
currentHouseInspectS = 0
currentInspectedAdorneeS = nil
currentInspectedPartS = nil
permRagdollRunningS = false
returnPosS = CFrame.new(0, 0, 0)
mouseTargetS = nil


infJumpD = false
inspectD = false
slideTPD = false
ragdollSpamD = false
ragdollLoopD = false


highlight = Instance.new("Highlight")
highlight.Name = "highlight"
highlight.Enabled = true
highlight.FillTransparency = 0.9
highlight.OutlineTransparency = 0

billboard = Instance.new("BillboardGui")
billboard.Name = "billboard"
billboard.Size = UDim2.new(0, 100, 0, 150)
billboard.StudsOffset = Vector3.new(0, 1, 0)
billboard.AlwaysOnTop = true

scrollframe = Instance.new("ScrollingFrame")
scrollframe.Name = "scrollframe"
scrollframe.ScrollingEnabled = false
scrollframe.BackgroundTransparency = 0.7

textlabel = Instance.new("TextLabel")
textlabel.Name = "textlabel"
textlabel.TextScaled = true
textlabel.BackgroundTransparency = 1
Whitelist = {
    "",
}

function updateCurrentBlobmanF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    for _, blobs in workspace:GetDescendants() do
        if blobs.Name ~= "CreatureBlobman" then continue end
        if not blobs:FindFirstChild("VehicleSeat") then continue end
        if not blobs.VehicleSeat:FindFirstChild("SeatWeld") then continue end
        if blobs.VehicleSeat.SeatWeld.Part1 == hrp then
            currentBlobS = blobs
        end
    end
end

function blobGrabF(blob, target, side)
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    local args = {
        [1] = blob:FindFirstChild(side.."Detector"),
        [2] = target,
        [3] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        }
        blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(unpack(args))
end

function blobDropF(blob, target, side)
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    local args = {
        [1] = blob:FindFirstChild(side.."Detector"):FindFirstChild(side.."Weld"),
        [2] = target,
        }
        blob.BlobmanSeatAndOwnerScript.CreatureDrop:FireServer(unpack(args))
end

function silentBlobGrabF(blob, target, side)
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    local args = {
        [1] = blob:FindFirstChild(side.."Detector"),
        [2] = target,
        [3] = blob:FindFirstChild(side.."Detector").AttachPlayer,
        }
        blob.BlobmanSeatAndOwnerScript.CreatureGrab:FireServer(unpack(args))
end

function updateCurrentHouseF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if char.Parent == workspace then
        currentHouseS = 0
    elseif char.Parent.Name == "PlayersInPlots" then
        for i, e in workspace.Plots:GetChildren() do
            for i, e in e.PlotSign.ThisPlotsOwners:GetChildren() do
                if e.Value == plr.Name then
                    if e.Parent.Parent.Parent.Name == "Plot1" then
						currentHouseS = 1
					elseif e.Parent.Parent.Parent.Name == "Plot2" then
						currentHouseS = 2
					elseif e.Parent.Parent.Parent.Name == "Plot3" then
						currentHouseS = 3
					elseif e.Parent.Parent.Parent.Name == "Plot4" then
						currentHouseS = 4
					elseif e.Parent.Parent.Parent.Name == "Plot5" then
						currentHouseS = 5
					end
                end
            end
        end
	end
end

function mouseTargetInspectF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if mouse.Target then
        if mouse.Target.Parent:FindFirstChildOfClass("Humanoid") then
            currentInspectS = 1
            currentHouseInspectS = 0
        elseif mouse.Target.Parent:IsDescendantOf(workspace.Plots) then
                local current = mouse.Target
                repeat
                   current = current.Parent
                until string.match(current.Name, "Plot")
                for i = 1, 5 do
                    if current.Name == "Plot"..i then
                        currentHouseInspectS = i
                    end
                end
                currentInspectS = 2
        elseif mouse.Target.Parent:IsDescendantOf(workspace.PlotItems) or string.match(mouse.Target.Parent.Parent.Name, "SpawnedInToys") or mouse.Target.Parent.Parent:FindFirstChild("SpawningPlatform") then
            currentInspectS = 3
            currentHouseInspectS = 0
        else
            currentInspectS = 4
            currentHouseInspectS = 0
        end
    end
end


function flingF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    workspace.ChildAdded:Connect(function(model)
        if model.Name == "GrabParts" then
            local part_to_impulse = model["GrabPart"]["WeldConstraint"].Part1
            if part_to_impulse then
                model:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not model.Parent and flingT then
                        uis.InputBegan:Connect(function(inp, chat)
                            if inp.UserInputType == Enum.UserInputType.MouseButton2 then
                                local velocityObj = Instance.new("BodyVelocity", part_to_impulse)
                                velocityObj.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                                velocityObj.Velocity = cam.CFrame.lookVector * strengthV
                                deb:AddItem(velocityObj, 1)
                            end
                        end)
                    end
                end)
            end
        end
    end)
end

function killGrabF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    workspace.ChildAdded:Connect(function(e)
        if e.Name == "GrabParts" and killGrabT and e.GrabPart.WeldConstraint.Part1.Parent.Name ~= char.Name and not table.find(Whitelist, e.GrabPart.WeldConstraint.Part1.Parent.Name) then
            e.GrabPart.WeldConstraint.Part1.Parent:FindFirstChildOfClass("Humanoid").RigType = Enum.RigType.R15
        end
    end)
end

function infLineExtendF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    uis.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseWheel then
            if lineDistanceV < 11 then
                lineDistanceV = 11
            end
    
            if input.Position.Z > 0 then
                lineDistanceV = lineDistanceV + increaseLineExtendV
            elseif input.Position.Z < 0 then
                lineDistanceV = lineDistanceV - increaseLineExtendV
            end
        end
    end)
    
    workspace.ChildAdded:Connect(function(child)
        if child.Name == "GrabParts" and child:IsA("Model") then
            if infLineExtendT and uis.MouseEnabled then
                local grabPartsModel = child

                grabPartsModel:WaitForChild("GrabPart")
                grabPartsModel:WaitForChild("DragPart")
                    
                local clonedDragPart = grabPartsModel.DragPart:Clone()
                clonedDragPart.Name = "DragPart1"
                clonedDragPart.AlignPosition.Attachment1 = clonedDragPart.DragAttach
                clonedDragPart.Parent = grabPartsModel
                
                lineDistanceV = (clonedDragPart.Position - cam.CFrame.Position).Magnitude
    
                clonedDragPart.AlignOrientation.Enabled = false
                grabPartsModel.DragPart.AlignPosition.Enabled = false
    
                task.spawn(function()
                    while grabPartsModel.Parent do
                        clonedDragPart.Position = cam.CFrame.Position + cam.CFrame.LookVector * lineDistanceV
                        task.wait()
                    end
            
                    lineDistanceV = 0
                end)
            end
        end
    end)
end


function antiGrab1F()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    while antiGrab1T and task.wait() do
        if plr.IsHeld.Value == true and antiGrab1T == true then
            if hrp ~= nil then
                if antiGrab1AnchorT then
                    hrp.Anchored = true
                    while plr.IsHeld.Value == true do rs.CharacterEvents.Struggle:FireServer(plr);wait(0.001) end
                    hrp.Anchored = false
                elseif not antiGrab1AnchorT then
                    while plr.IsHeld.Value == true do rs.CharacterEvents.Struggle:FireServer(plr);wait(0.001) end
                end
            end
        end
    end
end

function antiBlob1F()
    workspace.DescendantAdded:Connect(function(toy)
        if toy.Name == "CreatureBlobman" and toy.Parent ~= inv and antiBlob1T then
            wait()
            toy.LeftDetector:Destroy()
            toy.RightDetector:Destroy()
        end
    end)
end

function antiExplodeF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    workspace.ChildAdded:Connect(function(model)
        if model.Name == "Part" and char ~= nil and antiExplodeT then
            local mag = (model.Position - hrp.Position).Magnitude
            if mag <= 20 then
                hrp.Anchored = true
				wait(0.01)
                while char["Right Arm"].RagdollLimbPart.CanCollide == true do wait(0.001) end
                hrp.Anchored = false
            end
        end
    end)
end

function antiLagF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if antiLagT == true then
        plr.PlayerScripts.CharacterAndBeamMove.Disabled = true
    elseif antiLagT == false then
        plr.PlayerScripts.CharacterAndBeamMove.Enabled = true
    end
end

function antiStickyF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if antiStickyT == true then
        plr.PlayerScripts.StickyPartsTouchDetection.Disabled = true
    elseif antiStickyT == false then
        plr.PlayerScripts.StickyPartsTouchDetection.Enabled = true
    end
end


function getPlayerList()
    local playerList = {}
    for _, p in pairs(game.Players:GetPlayers()) do
        if p ~= plr and (p.Name ~= "SaviorLiberty" or p.Name ~= "R0tationCurveKey") then
            table.insert(playerList, p.Name .. " (" .. p.DisplayName .. ")")
        end
    end
    return playerList
end

function loopPlayerBlobF()
    updateCurrentBlobmanF()
    for i, e in ipairs(playersInLoop2V) do
        local player
        if game.Players:FindFirstChild(e) then
            player = game.Players:FindFirstChild(e)
        else
            continue
        end
        if blobLoopT then
            blobGrabF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left")
            wait(0.05)
            blobDropF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left")
            wait(0.05)
            silentBlobGrabF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left")
        end
    end
    while task.wait(6.25) and blobLoopT do
        for i, e in ipairs(playersInLoop2V) do
            local player
            if game.Players:FindFirstChild(e) then
                player = game.Players:FindFirstChild(e)
            else
                continue
            end
            blobGrabF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left")
            wait(0.05)
            blobDropF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left")
            wait(0.05)
            silentBlobGrabF(currentBlobS, player.Character:WaitForChild("HumanoidRootPart"), "Left")
        end
    end
end


function updateWalkSpeedF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if walkSpeedT then
        hum.WalkSpeed = walkSpeedV
    elseif not walkSpeedT then
        hum.WalkSpeed = 16
    end
    hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if walkSpeedT then
            hum.WalkSpeed = walkSpeedV
        elseif not walkSpeedT then
            hum.WalkSpeed = 16
        end
    end)
end

function updateJumpPowerF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if jumpPowerT then
        hum.JumpPower = jumpPowerV
    elseif not jumpPowerT then
        hum.JumpPower = 24
    end
end

function updateNoClipF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    while noClipT and task.wait(0.1) do
        char.Head.CanCollide = false
        char.Torso.CanCollide = false
    end
    if not noClipT then
        char.Head.CanCollide = true
        char.Torso.CanCollide = true
    end
end

function updateInfJumpF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    uis.JumpRequest:Connect(function()
        if infJumpT and not infJumpD then
            infJumpD = true
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            wait()
            infJumpD = false
        end
    end)
end

function updateFloatF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if floatT then
    local float = Instance.new('Part')
    float.Name = "floatPart"
    float.Parent = char
    float.Transparency = 1
    float.Size = Vector3.new(2,0.2,1.5)
    float.Anchored = true
    float.CFrame = hrp.CFrame * CFrame.new(0, floatY, 0)
    local function floatLoop()
        if char:FindFirstChild("floatPart") and hrp then
            float.CFrame = hrp.CFrame * CFrame.new(0, floatY, 0)
        end
    end			
    floatFunc = rs2.Heartbeat:Connect(floatLoop)
    elseif not floatT then
        if char:FindFirstChild("floatPart") then
            char:FindFirstChild("floatPart"):Destroy()
        end
    end
end

function masslessF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    for i, e in char:GetChildren() do
        if e:IsA("BasePart") and masslessT then
            e.Massless = true
        elseif e:IsA("BasePart") and not masslessT then
            e.Massless = false
        end
    end
end



function updateBlobLoopServerF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    updateCurrentBlobmanF()
    for i, e in game.Players:GetPlayers() do
        if e.Character:FindFirstChild("HumanoidRootPart") == nil then continue end
        if e.Character:FindFirstChild("HumanoidRootPart") and hum then
            if currentBlobS ~= nil and blobLoopServerT then
                blobGrabF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left")
                wait(0.05)
                blobDropF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left")
                wait(0.05)
                silentBlobGrabF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left")
            end
        end
    end
    while blobLoopServerT and task.wait(6.25) do
        for i, e in game.Players:GetPlayers() do
            if e.Character:FindFirstChild("HumanoidRootPart") == nil then continue end
            if e.Character:FindFirstChild("HumanoidRootPart") and hum then
                if currentBlobS ~= nil and blobLoopServerT then
                    blobGrabF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left")
                    wait(0.05)
                    blobDropF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left")
                    wait(0.05)
                    silentBlobGrabF(currentBlobS, e.Character:WaitForChild("HumanoidRootPart"), "Left")
                end
            end
        end
    end
end

function lagF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
		for i, e in game.Players:GetPlayers() do
			if table.find(Whitelist, e.Name) then
				return
			end
		end
    while wait(1) and lagT do
        for a = 0, linesV do
            for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
                if player.Character.Torso ~= nil then
                    rs.GrabEvents.CreateGrabLine:FireServer(player.Character.Torso, player.Character.Torso.CFrame)
                end
            end
        end
    end
end

function pingF()
		for i, e in game.Players:GetPlayers() do
			if table.find(Whitelist, p.Name) then
				return
			end
		end
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    while task.wait() and pingT do
        rs.GrabEvents.ExtendGrabLine:FireServer(string.rep("Balls Balls Balls Balls", packetsV))
    end
end

function shurikenLagServerF()
		for i, e in game.Players:GetPlayers() do
			if table.find(Whitelist, p.Name) then
				return
			end
		end
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if shurikenLagServerT then
        local ToyFolder
        for _, v in pairs(workspace.Plots:GetChildren()) do
            for _, b in pairs(v.PlotSign.ThisPlotsOwners:GetChildren()) do
                if b.Value == plr.Name then
                    ToyFolder = workspace.PlotItems[v.Name]
                end
            end
        end
        local decoys = {}
        local shurikens = {}

        for _, obj in pairs(ToyFolder:GetChildren()) do
            if obj:IsA("Model") then
                if obj.Name == "NpcRobloxianMascot" then
                    table.insert(decoys, obj)
                elseif obj.Name == "NinjaShuriken" then
                    table.insert(shurikens, obj)
                end
            end
        end

        local maxshurikensperdecoy = 8

        for decoyindex, decoy in ipairs(decoys) do
            local decoyHRP = decoy:FindFirstChild("HumanoidRootPart")
            if decoyHRP and shurikenLagServerT then
                local startindex = (decoyindex - 1) * maxshurikensperdecoy + 1
                local endindex = startindex + maxshurikensperdecoy - 1
                for shurikenindex = startindex, endindex do
                    local shuriken = shurikens[shurikenindex]
                    if not shuriken then
                        break
                    end
                    local StickyPart = shuriken:FindFirstChild("StickyPart")
                    if StickyPart then
                        StickyPart.CanTouch = true
                        for _, part in pairs(decoy:GetDescendants()) do
                            if part:IsA("BasePart") then
                                part.CanCollide = false
                            end
                        end
                        local BodyPosition = Instance.new("BodyPosition")
                        BodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                        BodyPosition.P = 10000
                        BodyPosition.D = 500
                        BodyPosition.Parent = StickyPart
                        for _, part in pairs(shuriken:GetDescendants()) do
                            if part:IsA("BasePart") then
                                part.CanCollide = false
                            end
                        end
                        for _, child in pairs(StickyPart:GetChildren()) do
                            if child.Name == "TouchInterest" then
                                child:Destroy()
                            end
                        end
                        task.defer(function()
                            repeat
                                StickyPart.AssemblyAngularVelocity = Vector3.new(
                                    math.random(-100, 100) * 50,
                                    math.random(-100, 100) * 50,
                                    math.random(-100, 100) * 50
                                )
                                BodyPosition.Position = Vector3.new(
                                    decoyHRP.Position.X,
                                    decoyHRP.Position.Y - 4,
                                    decoyHRP.Position.Z
                                )
                                wait(0.0001)
                                BodyPosition.Position = Vector3.new(
                                    decoyHRP.Position.X,
                                    decoyHRP.Position.Y + 3,
                                    decoyHRP.Position.Z
                                )
                                wait(0.0001)
                            until not shurikenLagServerT or not shuriken.Parent or not decoy.Parent
                        end)
                    end
                    wait()
                end
            end
            wait()
        end
    end
end


function tpF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if not slideTPT then
        if char and hrp and mouse.Target and not slideTPT then hrp.CFrame = CFrame.new(mouse.Hit.x, mouse.Hit.y + 5, mouse.Hit.z) end
    elseif slideTPT then
        if not slideTPD and slideTPT and mouse.Target then
            slideTPD = true
            local info = TweenInfo.new(
                0.5, 
                Enum.EasingStyle.Sine, 
                Enum.EasingDirection.In,
                0,
                false,
                0
            )
            local info2 = TweenInfo.new(
                0.5, 
                Enum.EasingStyle.Sine, 
                Enum.EasingDirection.In,
                0,
                true,
                0
            )
            local e = {["CFrame"] = CFrame.new(mouse.Hit.x, mouse.Hit.y + 3, mouse.Hit.z)}
            local e2 = {FieldOfView = 100}
            char.Head.CanCollide = false
            char.Torso.CanCollide = false
            game:GetService("TweenService"):Create(hrp, info, e):Play()
            game:GetService("TweenService"):Create(cam, info2, e2):Play()
            wait(0.55)
            char.Head.CanCollide = true
            char.Torso.CanCollide = true
            cam.FieldOfView = 70
            slideTPD = false
        end
    end
end

function floatUpF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if floatUpT and not floatDownT then
        floatY = -1.6
    elseif not floatUpT then
        floatY = -3.1
    end
end

function floatDownF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if floatDownT and not floatUpT then
        floatY = -3.6
    elseif not floatDownT then
        floatY = -3.1
    end
end

function inspectF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    mouseTargetInspectF()
    inspectInfoF()
    if not inspectD then
        inspectD = true
        if inspectT then
            if currentInspectS == 1 then
                currentInspectedAdorneeS = mouse.Target.Parent
                currentInspectedPartS = mouse.Target
                highlightC = highlight:Clone()
                highlightC.Adornee = mouse.Target.Parent
                highlightC.Parent = mouse.Target
                highlightC.FillColor = Color3.fromRGB(255, 255, 255)
                highlightC.OutlineColor = Color3.fromRGB(160, 11, 11)
            elseif currentInspectS == 2 then
                currentInspectedAdorneeS = workspace.Plots:FindFirstChild("Plot"..currentHouseInspectS)
                currentInspectedPartS = mouse.Target
                highlightC = highlight:Clone()
                highlightC.Adornee = workspace.Plots:FindFirstChild("Plot"..currentHouseInspectS)
                highlightC.Parent = mouse.Target
                highlightC.FillColor = Color3.fromRGB(255, 255, 255)
                highlightC.OutlineColor = Color3.fromRGB(0, 60, 180)
            elseif currentInspectS == 3 then
                currentInspectedAdorneeS = mouse.Target.Parent
                currentInspectedPartS = mouse.Target
                highlightC = highlight:Clone()
                highlightC.Adornee = mouse.Target.Parent
                highlightC.Parent = mouse.Target
                highlightC.FillColor = Color3.fromRGB(255, 255, 255)
                highlightC.OutlineColor = Color3.fromRGB(20, 170, 20)
            elseif currentInspectS == 4 then
                currentInspectedAdorneeS = mouse.Target.Parent
                currentInspectedPartS = mouse.Target
                highlightC = highlight:Clone()
                highlightC.Adornee = mouse.Target.Parent
                highlightC.Parent = mouse.Target
                highlightC.FillColor = Color3.fromRGB(255, 255, 255)
                highlightC.OutlineColor = Color3.fromRGB(180, 20, 180)
            end
        elseif not inspectT then
            currentInspectS = 0
            currentHouseInspectS = 0
            currentInspectedPartS = nil
            currentInspectedAdorneeS = nil
            highlightC:Destroy()
        end
        wait(0.1)
        inspectD = false
    end
end

function inspectInfoF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if not inspectInfoOnT and inspectInfoT and inspectT and currentInspectS ~= 0 and currentInspectedPartS ~= nil and currentInspectedAdorneeS ~= nil then
        inspectInfoOnT = true
        billboardC = billboard:Clone()
        billboardC.Adornee = currentInspectedAdorneeS
        billboardC.Parent = currentInspectedPartS

        scrollframeC = scrollframe:Clone()
        scrollframeC.Parent = billboardC
        scrollframeC.Size = UDim2.new(0, 160, 0, 40)
        scrollframeC.ScrollBarImageTransparency = 1 

        textlabelC1 = textlabel:Clone()
        textlabelC1.Parent = scrollframeC
        textlabelC1.Size = UDim2.new(0, 140, 0, 40)
        if currentInspectS == 1 then
            textlabelC1.Text = currentInspectedAdorneeS.Name.." ("..game.Players:FindFirstChild(currentInspectedAdorneeS.Name).DisplayName..")"
        else
            textlabelC1.Text = currentInspectedAdorneeS.Name
        end
    elseif not inspectInfoT and inspectInfoOnT or not inspectT and inspectInfoOnT then
        inspectInfoOnT = false
        inspectInfoT = false
        billboardC:Destroy()
    end
end

function inspectBringF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if inspectT and currentInspectS ~= 2 and currentInspectS ~= 4 then
        returnPosS = hrp.CFrame
        hrp.CFrame = currentInspectedAdorneeS.PrimaryPart.CFrame + Vector3.new(7, 3, 0)
        wait(0.15)
        if currentInspectS == 1 then
            rs.GrabEvents.SetNetworkOwner:FireServer(currentInspectedAdorneeS:WaitForChild("HumanoidRootPart"), currentInspectedAdorneeS:WaitForChild("HumanoidRootPart").CFrame)
            wait(0.1)
            currentInspectedAdorneeS:WaitForChild("HumanoidRootPart").CFrame = returnPosS
        else
            rs.GrabEvents.SetNetworkOwner:FireServer(currentInspectedAdorneeS.PrimaryPart, currentInspectedAdorneeS.PrimaryPart.CFrame)
            wait(0.1)
            currentInspectedAdorneeS.PrimaryPart.CFrame = returnPosS
        end
        hrp.CFrame = returnPosS
    elseif not inspectT then
        if mouse.Target.Parent:IsDescendantOf(workspace.PlotItems) or string.match(mouse.Target.Parent.Parent.Name, "SpawnedInToys") or mouse.Target.Parent.Parent:FindFirstChild("SpawningPlatform") or mouse.Target.Parent:FindFirstChildOfClass("Humanoid") then
            returnPosS = hrp.CFrame
            mouseTargetS = mouse.Target
            hrp.CFrame = mouseTargetS.Parent.PrimaryPart.CFrame + Vector3.new(10, 3, 0)
            wait(0.15)
            if mouseTargetS.Parent:FindFirstChildOfClass("Humanoid") then
                rs.GrabEvents.SetNetworkOwner:FireServer(mouseTargetS.Parent:WaitForChild("HumanoidRootPart"), mouseTargetS.Parent:WaitForChild("HumanoidRootPart").CFrame)
                wait(0.1)
                mouseTargetS.Parent:WaitForChild("HumanoidRootPart").CFrame = returnPosS
            else
                rs.GrabEvents.SetNetworkOwner:FireServer(mouseTargetS.Parent.PrimaryPart, mouseTargetS.Parent.PrimaryPart.CFrame)
                wait(0.1)
                mouseTargetS.Parent.PrimaryPart.CFrame = returnPosS
            end
            hrp.CFrame = returnPosS
            mouseTargetS = nil
        end
    end
end

function ragdollSpamF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    while ragdollSpamT and not ragdollSpamD and not permRagdollT do
        ragdollSpamD = true
            local args = {
                [1] = hrp,
                [2] = 0
            }
            rs:WaitForChild("CharacterEvents"):WaitForChild("RagdollRemote"):FireServer(unpack(args))
        task.wait(0.02)
        ragdollSpamD = false
    end
end

function setRagdollF(state)
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if char and char:FindFirstChild("HumanoidRootPart") then
        rs:WaitForChild("CharacterEvents"):WaitForChild("RagdollRemote"):FireServer(hrp, state and 1 or 0)
        if hum then hum.PlatformStand = state end
    end
end

function permRagdollLoopF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if permRagdollRunningS then return end
    permRagdollRunningS = true
    while permRagdollT do
        setRagdollF(true)
        task.wait(0.5)
    end
    permRagdollRunningS = false
    setRagdollF(false)
end
function grabBlobmanF2()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    print("LOL")
end
function getBlobmanF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    updateCurrentHouseF()
    if currentHouseS == 0 then
        if inv then return inv:FindFirstChild("CreatureBlobman") end
        return nil
    else
        return workspace.PlotItems:FindFirstChild("Plot"..currentHouseS):FindFirstChild("CreatureBlobman")
    end
end

function spawnBlobmanF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    local spawnRemote = rs:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction")
    if spawnRemote then
        pcall(function()spawnRemote:InvokeServer("CreatureBlobman", hrp.CFrame*CFrame.new(0,0,-5),Vector3.new(0, -15.716, 0))end)
        task.wait(1)
        blobmanInstanceS = getBlobmanF()
    end
end

function destroyBlobmanF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if blobmanInstanceS and destroyAutoGucciT then
        if currentHouseS == 0 then
            local args = {[1] = blobmanInstanceS}
            local destroyRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("DestroyToy")
            if destroyRemote then pcall(function()destroyRemote:FireServer(unpack(args))end)end
            blobmanInstanceS = nil
        else
            blobmanInstanceS.HumanoidRootPart.CFrame = workspace.Plots:FindFirstChild("Plot"..currentHouseS).TeslaCoil.ZapPart.CFrame
            blobmanInstanceS = nil
        end
    end
end

function ragdollLoopF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if ragdollLoopD then return end
    ragdollLoopD = true
    while sitJumpT do
        if char and hrp then
            local args={[1] = hrp, [2] = 0}
            rs:WaitForChild("CharacterEvents"):WaitForChild("RagdollRemote"):FireServer(unpack(args))
        end
        task.wait()
    end
    ragdollLoopD = false
end

function sitJumpF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if not char or not hum then return end
    local startTime = tick()
    while autoGucciT and tick()-startTime<6 do
        if blobmanInstanceS then
            local seat = blobmanInstanceS:FindFirstChildWhichIsA("VehicleSeat")
            if seat and seat.Occupant ~= hum then seat:Sit(hum) end
        end
        task.wait(0.1)
        if char and hum then hum:ChangeState(Enum.HumanoidStateType.Jumping)end
        task.wait(0.1)
    end
    if blobmanInstanceS then destroyBlobmanF() end
    autoGucciT = false
    sitJumpT = false
end

function stopVelocityF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    hrp.AssemblyLinearVelocity = Vector3.zero
end

function zoomF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if zoomT then
        cam.FieldOfView = zoomV
    elseif not zoomT then
        cam.FieldOfView = 70
    end
end


function addToysF()
end


function spychatF()
    local char = plr.Character
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    publicItalics = true
    privateProperties = {
        Color = Color3.fromRGB(245, 245, 40); 
        Font = Enum.Font.SourceSansBold;
        TextSize = 18;
    }
    local StarterGui = game:GetService("StarterGui")
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() or Players.LocalPlayer
    local saymsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")
    local getmsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("OnMessageDoneFiltering")
    local instance = (_G.chatSpyInstance or 0) + 1
    _G.chatSpyInstance = instance
    local function onChatted(p, msg)
	if p.Name == "SaviorLiberty" then return end
        if _G.chatSpyInstance == instance then
            if spychatT and (spySelfT or p~=player) then
                msg = msg:gsub("[\n\r]",''):gsub("\t",' '):gsub("[ ]+",' ')
                local hidden = true
                local conn = getmsg.OnClientEvent:Connect(function(packet,channel)
                    if packet.SpeakerUserId==p.UserId and packet.Message==msg:sub(#msg-#packet.Message+1) and (channel=="All" or (channel=="Team" and not publicSpyT and Players[packet.FromSpeaker].Team==player.Team)) then
                        hidden = false
                    end
                end)
                wait(1)
                conn:Disconnect()
                if hidden and spychatT then
                    if publicSpyT then
                        saymsg:FireServer((publicItalics and '').."{SPY} [".. p.Name .. "(" .. p.DisplayName .. ")" .."]: "..msg,"All")
                    else
                        privateProperties.Text = "{SPY} [".. p.Name .. "(" .. p.DisplayName .. ")" .."]: "..msg
                        StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
                    end
                end
            end
        end
    end
    for _,p in ipairs(Players:GetPlayers()) do
        p.Chatted:Connect(function(msg) onChatted(p,msg) end)
    end
    Players.PlayerAdded:Connect(function(p)
        p.Chatted:Connect(function(msg) onChatted(p,msg) end)
    end)
    privateProperties.Text = "{SPY "..(spychatT and "EN" or "DIS").."ABLED}"
    StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
    if not player.PlayerGui:FindFirstChild("Chat") then wait(3) end
    local chatFrame = player.PlayerGui.Chat.Frame
    chatFrame.ChatChannelParentFrame.Visible = true
    chatFrame.ChatBarParentFrame.Position = chatFrame.ChatChannelParentFrame.Position+UDim2.new(UDim.new(),chatFrame.ChatChannelParentFrame.Size.Y)
end

local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local GrabEvents = ReplicatedStorage:WaitForChild("GrabEvents")
local SetNetworkOwner = GrabEvents:WaitForChild("SetNetworkOwner")

local toysFolder = ReplicatedStorage:FindFirstChild("ToysFolder") or Instance.new("Folder", ReplicatedStorage)
toysFolder.Name = "ToysFolder"

local function spawnItem(itemName, position, orientation)
    task.spawn(function()
        local cframe = CFrame.new(position)
        local rotation = Vector3.new(0, 90, 0)
        ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(itemName, cframe, rotation)
    end)
end

local function getDescendantParts(name)
    local parts = {}
    for _, descendant in ipairs(workspace:GetDescendants()) do
        if descendant:IsA("BasePart") and descendant.Name == name then
            table.insert(parts, descendant)
        end
    end
    return parts
end


local playerList = {}

local function updatePlayerList()
    playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(playerList, player.Name)
    end
end

local function onPlayerAdded(player)
    table.insert(playerList, player.Name)
end

local function onPlayerRemoving(player)
    for i, name in ipairs(playerList) do
        if name == player.Name then
            table.remove(playerList, i)
            break
        end
    end
end


local currentKunai = nil
local kunaiSpawningEnabled = false

local function spawnItemCf(itemName, cframe)
    local rotation = Vector3.new(90, 90, 0)
    local toy = ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(itemName, cframe, rotation)
    return toy
end

local function attachKunaiToThigh()
    if currentKunai and currentKunai.Parent then 
        return 
    end
    local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local torso = playerCharacter:WaitForChild("Torso", 5)
    if torso then
        local kunaiPosition = torso.CFrame
            * CFrame.new(-0.5, -torso.Size.Y / 2, 0)
            * CFrame.Angles(math.rad(-100), 0, 0)
        spawnItemCf("NinjaKunai", kunaiPosition)
        for i = 1, 20 do
            local toysFolder = workspace:FindFirstChild(localPlayer.Name .. "SpawnedInToys")
            if toysFolder then
                currentKunai = toysFolder:FindFirstChild("NinjaKunai")
                if currentKunai then
                    break
                end
            end
            task.wait()
        end
        if currentKunai then
            currentKunai.AncestryChanged:Connect(function(_, parent)
                if not parent and kunaiSpawningEnabled then
                    currentKunai = nil
                    attachKunaiToThigh()
                end
            end)
        else
            task.wait(1)
            attachKunaiToThigh()
        end
    end
end

local function monitorKunai()
    while kunaiSpawningEnabled do
        if not (currentKunai and currentKunai.Parent) then
            currentKunai = nil
            attachKunaiToThigh()
        end
        task.wait()
    end
end

local function initializeKunai()
    attachKunaiToThigh()
    task.spawn(monitorKunai)
end

local function disableKunai()
    kunaiSpawningEnabled = false
    if currentKunai then
        currentKunai:Destroy()
        currentKunai = nil
    end
end





local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local currentKunai = nil
local kunaiSpawningEnabled = false

local function spawnItemCf(itemName, cframe)
    local rotation = Vector3.new(90, 90, 0)
    local toy = ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(itemName, cframe, rotation)
    return toy
end

local function attachKunaiToThigh()
    if currentKunai and currentKunai.Parent then 
        return 
    end
    local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local torso = playerCharacter:WaitForChild("Torso", 5)
    if torso then
        local kunaiPosition = torso.CFrame
            * CFrame.new(-0.5, -torso.Size.Y / 2, 0)
            * CFrame.Angles(math.rad(-100), 0, 0)
        spawnItemCf("NinjaKunai", kunaiPosition)
        for i = 1, 20 do
            local toysFolder = workspace:FindFirstChild(localPlayer.Name .. "SpawnedInToys")
            if toysFolder then
                currentKunai = toysFolder:FindFirstChild("NinjaKunai")
                if currentKunai then
                    break
                end
            end
            task.wait()
        end
        if currentKunai then
            currentKunai.AncestryChanged:Connect(function(_, parent)
                if not parent and kunaiSpawningEnabled then
                    currentKunai = nil
                    attachKunaiToThigh()
                end
            end)
        else
            task.wait(1)
            attachKunaiToThigh()
        end
    else
        warn("Torso not found!")
    end
end

local function monitorKunai()
    while kunaiSpawningEnabled do
        if not (currentKunai and currentKunai.Parent) then
            currentKunai = nil
            attachKunaiToThigh()
        end
        task.wait()
    end
end

local function initializeKunai()
    attachKunaiToThigh()
    task.spawn(monitorKunai)
end

local function disableKunai()
    kunaiSpawningEnabled = false
    if currentKunai then
        currentKunai:Destroy()
        currentKunai = nil
    end
end





local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local localPlayer = Players.LocalPlayer
local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()

local isEnabled = false
local activeLoop = nil
local bodyVelocity

local function MoveBodyPartsInsideHumanoid(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and (part.Name ~= "HumanoidRootPart") then
            part.Position = rootPart.Position
            part.Velocity = Vector3.zero
            part.RotVelocity = Vector3.zero
        end
    end
end

local function MoveCharacterDown(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    local ray = Ray.new(rootPart.Position, Vector3.new(0, -100, 0))
    local hit, position = workspace:FindPartOnRay(ray, character)
    if hit then
        rootPart.CFrame = CFrame.new(position + Vector3.new(0, 3, 0))
    end
end

local function HandleMovement(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    local moveDirection = Vector3.zero
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
        moveDirection += rootPart.CFrame.LookVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        moveDirection -= rootPart.CFrame.LookVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
        moveDirection -= rootPart.CFrame.RightVector
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
        moveDirection += rootPart.CFrame.RightVector
    end
    bodyVelocity.Velocity = moveDirection * 100
end

local function HandleRagdoll(character)
    if activeLoop then
        activeLoop:Disconnect()
    end
    local humanoid = character:FindFirstChild("Humanoid")
    local ragdolled = humanoid and humanoid:FindFirstChild("Ragdolled")
    if not humanoid or not ragdolled then return end
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Parent = character.HumanoidRootPart
    activeLoop = RunService.Heartbeat:Connect(function()
        if isEnabled and ragdolled.Value then
            MoveBodyPartsInsideHumanoid(character)
            MoveCharacterDown(character)
            HandleMovement(character)
        end
    end)
end

local function SetupCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")
    local ragdolled = humanoid:WaitForChild("Ragdolled")
    ragdolled:GetPropertyChangedSignal("Value"):Connect(function()
        if ragdolled.Value then
            HandleRagdoll(character)
        elseif activeLoop then
            activeLoop:Disconnect()
            activeLoop = nil
            if bodyVelocity then
                bodyVelocity:Destroy()
            end
        end
    end)
    if ragdolled.Value then
        HandleRagdoll(character)
    end
end


if L.vhsows then
local Main9Tab = Window:MakeTab({
    Name = "Anti",
    Icon = "rbxassetid://18719810809",
    PremiumOnly = false
})



Main9Tab:AddToggle({
    Name = "Anti-Explosion (Move)",
    Default = false,
    Callback = function(enabled)
        isEnabled = enabled
        if enabled then
            if playerCharacter then
                SetupCharacter(playerCharacter)
            end
            localPlayer.CharacterAdded:Connect(function(character)
                playerCharacter = character
                SetupCharacter(character)
            end)
        elseif activeLoop then
            activeLoop:Disconnect()
            activeLoop = nil
            if bodyVelocity then
                bodyVelocity:Destroy()
            end
        end
    end
})





Main9Tab:AddToggle({
	Name = "Anti-Grab (Gucci)",
	Default = false,
	Callback = function(Value)
        autoGucciT = Value
        if autoGucciT then
            spawnBlobmanF()
            task.wait(1.1)
            if not sitJumpT then
                coroutine.wrap(sitJumpF)()
                sitJumpT = true
            end
            coroutine.wrap(ragdollLoopF)()
        else
            sitJumpT = false
        end
    end
})

Main9Tab:AddToggle({
	Name = "Destroy Gucci",
	Default = false,
	Callback = function(Value)
        destroyAutoGucciT = Value
    end
})

Main9Tab:AddToggle({
	Name = "Anti Kick",
	Default = false,
	Callback = function(Value)
				antikick = Value
				local function f()
					if S.w:FindFirstChild(O.myname) then
						local hrp,hum = get_all()
						local v5 = hrp.Parent["Right Leg"]
						local v6 = hum
						local v7 = hrp
						if v5 and v6 and v7 then
							if v6.Health ~= 0 and v6:GetState() ~= Enum.HumanoidStateType.Dead and not(O.me.InPlot.Value) then
								local v1 = O.backpack:FindFirstChild("NinjaKunai")
								if v1 then
									local v2 = v1:FindFirstChild("StickyPart")
									if v2 then
										local v3 = v2:FindFirstChild("StickyWeld")
										if v3 then
											local v4 = v3.Part1
											if v4 then
												if v4 ~= v5 then O.Events.DestroyToyEvent:FireServer(v1);task.wait() ; f() end

											else O.Events.DestroyToyEvent:FireServer(v1);task.wait() ; f() end
										else O.Events.DestroyToyEvent:FireServer(v1);task.wait() ; f() end
									else O.Events.DestroyToyEvent:FireServer(v1);task.wait() ; f() end

								elseif not(O.me.InPlot.Value) and O.me.CanSpawnToy.Value then
									if lastt then lastt = false; task.wait(0.5) end
									task.spawn(toy_spawn2,"NinjaKunai")
									while not(O.backpack:FindFirstChild("NinjaKunai")) do task.wait() end
									local v8 = O.backpack:FindFirstChild("NinjaKunai").StickyPart
									local v9 = v8.StickyWeld
									auto_invis_touch(v8, v7)
									while v9.Part1 == nil do
										O.Events.StickyPartEvent:FireServer(v8,v5,CFrame.new(0.0490287527, -0.000000000000000, 0.00000000, -0.00000000, 0.00739139877, -0.999561906, -0.998452604, -0.0478846952, 0.0282763243, -0.0476547107, 0.99882561, 0.00000000000) * CFrame.Angles(0, 180, 0))
										task.wait()
									end
								elseif O.me.InPlot.Value then lastt = true end
							end
						end
					end
				end
				local lastt = false
				while antikick do
					f()
					task.wait()
				end
			end
		})
		
Main9Tab:AddToggle({
    Name = "Anti-Kick V2",
    Default = false,
    Color = Color3.fromRGB(153, 102, 204),
    Save = true,
    Flag = "AntiKick",
    Callback = function(enabled)
        if enabled then
            kunaiSpawningEnabled = true
            initializeKunai()
        else
            disableKunai()
        end
    end
})

Main9Tab:AddToggle({
  Name = "Anti Banana",
  Default = false,
  Callback = function(value32)
      pcall(function()
          toggleSitLock32(value32)
      end)
  end
})

UserInputService32 = game:GetService("UserInputService")
player32 = game.Players.LocalPlayer
character32 = player32.Character or player32.CharacterAdded:Wait()
humanoid32 = pcall(function() return character32:WaitForChild("Humanoid") end) and character32:WaitForChild("Humanoid") or nil

isSitLocked32 = false
SOUND_ON_ID32 = "rbxassetid://106145041472451" 
SOUND_OFF_ID32 = "rbxassetid://112496142134528" 

function playSound32(soundId)
  pcall(function()
      local soundInstance32 = Instance.new("Sound")
      soundInstance32.SoundId = soundId
      soundInstance32.Volume = 1
      soundInstance32.Parent = workspace
      soundInstance32:Play()
      soundInstance32.Ended:Connect(function()
          soundInstance32:Destroy()
      end)
  end)
end

 function sendNotification32(title, message)
  pcall(function()
      OrionLib:MakeNotification({
          Name = title,
          Content = message,
          Image = "rbxassetid://4483345998",
          Time = 5
      })
  end)
end

function toggleSitLock32(state32)
  if state32 then
      isSitLocked32 = true
      sendNotification32("Sit Lock", "Sit Lock ENABLED")
      playSound32(SOUND_ON_ID32)
      pcall(function()
          if humanoid32 then
              humanoid32.Sit = true
          end
      end)
  else
      if isSitLocked32 then
          sendNotification32("Sit Lock", "Sit Lock DISABLED")
          playSound32(SOUND_OFF_ID32)
      end
      isSitLocked32 = false
      pcall(function()
          if humanoid32 then
              humanoid32.Sit = false
          end
      end)
  end
end

function monitorHumanoid32()
  if not humanoid32 then return end

  pcall(function()
      humanoid32.Changed:Connect(function(property32)
          if property32 == "Sit" and isSitLocked32 then
              pcall(function()
                  if humanoid32 then
                      humanoid32.Sit = true
                  end
              end)
          end
      end)
  end)

  pcall(function()
      humanoid32.StateChanged:Connect(function(_, newState32)
          if isSitLocked32 then
              pcall(function()
                  if humanoid32 then
                      if newState32 == Enum.HumanoidStateType.Seated then
                          humanoid32:ChangeState(Enum.HumanoidStateType.Running)
                      elseif newState32 == Enum.HumanoidStateType.Freefall then
                          humanoid32:ChangeState(Enum.HumanoidStateType.Freefall)
                      end
                  end
              end)
          end
      end)
  end)
end

player32.CharacterAdded:Connect(function(newCharacter32)
  pcall(function()
      character32 = newCharacter32
      humanoid32 = character32:WaitForChild("Humanoid")

      if isSitLocked32 then
          pcall(function()
              if humanoid32 then
                  humanoid32.Sit = true
              end
          end)
      end

      monitorHumanoid32()
  end)
end)

pcall(monitorHumanoid32)







local running = false

local function monitorFireLight()
    running = true  
    local localPlayer = game.Players.LocalPlayer

    local function checkFireLight()
        while running do  
            local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

            while running and character.Parent do  
                local fireLight = humanoidRootPart:FindFirstChild("FireLight")
                if fireLight then
                    local barrier = workspace.Plots.Plot4.Barrier:GetChildren()[1]
                    local originalSize = barrier.Size
                    local originalCFrame = barrier.CFrame

                    barrier.Size = Vector3.new(0.5, 0.5, 0.5)
                    barrier.CFrame = humanoidRootPart.CFrame

                    task.wait(1)

                    barrier.Size = originalSize
                    barrier.CFrame = originalCFrame
                end
                task.wait()
            end
        end
    end

    localPlayer.CharacterAdded:Connect(function()
        if running then  
            task.spawn(checkFireLight)
        end
    end)

    task.spawn(checkFireLight)
end

Main9Tab:AddToggle({
    Name = "Anti-Burn",
    Default = false,
    Color = Color3.fromRGB(153, 102, 204),
    Save = true,
    Flag = "AntiFire",
    Callback = function(enabled)
        if enabled then
            if not running then  
                task.spawn(monitorFireLight)  
            end
        else
            running = false  
        end
    end
})

local antiVoidEnabled = false 

Main9Tab:AddButton({
    Name = "Anti Void [Fall and Ocean]",
    Callback = function()
        antiVoidEnabled = not antiVoidEnabled 

        
        local oceanModel = workspace.Map.AlwaysHereTweenedObjects.Ocean.Object.ObjectModel
        for _, part in ipairs(oceanModel:GetChildren()) do 
            if part:IsA("Part") then 
                part.CanCollide = antiVoidEnabled
            end
        end

        
        if antiVoidEnabled then
            game.Workspace.FallenPartsDestroyHeight = -999999999999999999999999 
        else
            game.Workspace.FallenPartsDestroyHeight = -100 
        end
    end    
})

local player = game:GetService("Players").LocalPlayer
local characterAndBeamMove = player.PlayerScripts:FindFirstChild("CharacterAndBeamMove")
local toggleEnabled = false

local function disableFunction()
    if characterAndBeamMove and characterAndBeamMove:IsA("Script") then
        characterAndBeamMove.Disabled = true
    end
end

local function enableFunction()
    if characterAndBeamMove and characterAndBeamMove:IsA("Script") then
        characterAndBeamMove.Disabled = false
    end
end

local function destroyGrabParts()
    for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
        if plr.Character and plr ~= player then
            local character = plr.Character
            if character:FindFirstChild("GrabParts") then
                local grabParts = character:FindFirstChild("GrabParts")
                if grabParts then
                    grabParts:Destroy()
                end
            end
        end
    end
end

local function toggleFunction(value)
    toggleEnabled = value
    if toggleEnabled then
        while toggleEnabled do
            destroyGrabParts()
            wait(1)
        end
    end
end

Main9Tab:AddToggle({
    Name = "Anti Lag",
    Default = false,
    Callback = function(Value)
        if Value then
            disableFunction()
            toggleFunction(true)
        else
            enableFunction()
            toggleEnabled = false
        end
    end    
})

local Section = Main9Tab:AddSection({
	Name = "Others"
})

Main9Tab:AddToggle({
	Name = "Perm Radgoll",
	Default = false,
	Callback = function(Value)
        permRagdollT = Value
        if permRagdollT and not permRagdollRunningS then
            coroutine.wrap(permRagdollLoopF)()
        elseif not permRagdollT then
            permRagdollRunningS = false
        end
    end
})

Main9Tab:AddButton({
	Name = "Radgoll Move",
	Callback = function()
        local char = plr.Character
        local hrp = char:WaitForChild("HumanoidRootPart")
        local hum = char:WaitForChild("Humanoid")
        hum.Sit = false
        hum.Ragdolled.Value = false
    end
})


end


if get_rank(O.me) > 1 then
	local msg = ""
	if check_list(Lt.admins, O.me.UserId) then msg = "" end
	if L.vhsows then msg = "" end
	O.Events.saymsg:FireServer(""..msg, "ALL")
	O.Events.saymsg:FireServer("", "All")
end

task.delay(1, function() Lt.ftapcolors = Ld.field.Theme.ftapc end)
task.delay(1, function() chamsfc = Ld.field.Theme.FillColor end)
task.delay(1, function() chamsoc = Ld.field.Theme.OutlineColor end)
task.delay(1, function() Ld.field:ChangeTheme("Default2") end)
task.delay(1, function() set_chams_parametr() end)
task.delay(1, function() set_ftap_color() end)
task.delay(1, function() set_line_color() end)
task.delay(1, function() datadssend() end)

Ld.field:LoadConfiguration()
  	end    
})

local ExplosionTab = Window:MakeTab({Name = "Auto Bombs", Icon =  "rbxassetid://18624610285", PremiumOnly = false})



local KeybindsTab = Window:MakeTab({Name = "Explosion", Icon =  "rbxassetid://7733946818", PremiumOnly = false})

local KeybindSection2 = KeybindsTab:AddSection({Name = "Loop Snowball"})
KeybindSection2:AddParagraph("Control Explosion Player", "Best")

KeybindSection2:AddButton({
	Name = "Loop Snowball",
	Callback = function()
local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/ionlyusegithubformcmods/1-Line-Scripts/main/Mobile%20Friendly%20Orion')))() 

local Window = OrionLib:MakeWindow({Name = "Loop Player", HidePremium = false, SaveConfig = true, ConfigFolder = "OrionTest"})


local ExplosionTab = Window:MakeTab({
    Name = "Loop Player",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

local Section = ExplosionTab:AddSection({
	Name = "Loop Snowball Explosion"
})

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local WhitelistedPlayers = {}

local function getTargetPlayer(targetPlayerName)
    return game.Players:FindFirstChild(targetPlayerName)
end

local selectedPlayers = {}

local whitelistDropdown = ExplosionTab:AddDropdown({
    Name = "Select Player",
    Options = {},
    Callback = function(player)
        selectedPlayers[player] = true
    end
})

local whitelistedDropdown = ExplosionTab:AddDropdown({
    Name = "Whitelisted Players",
    Options = {},
    Callback = function(player)
        selectedPlayers[player] = true
    end
})

local function updateWhitelistDropdown()
    local playerNames = {}
    for playerName in pairs(WhitelistedPlayers) do
        table.insert(playerNames, playerName)
    end
    whitelistedDropdown:Refresh(playerNames, true)
end

local function updatePlayerDropdown()
    local playerOptions = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player and not WhitelistedPlayers[p.Name] then
            local displayOption = p.Name .. " (" .. p.DisplayName .. ")"
            table.insert(playerOptions, displayOption)
        end
    end
    whitelistDropdown:Refresh(playerOptions, true)
end

Players.PlayerAdded:Connect(updatePlayerDropdown)
Players.PlayerRemoving:Connect(updatePlayerDropdown)

updatePlayerDropdown()
updateWhitelistDropdown()

ExplosionTab:AddButton({
    Name = "Add Player",
    Callback = function()
        for playerName in pairs(selectedPlayers) do
            local username = playerName:match("^(.-) %(") or playerName
            WhitelistedPlayers[username] = true
        end
        updateWhitelistDropdown()
        updatePlayerDropdown()
        selectedPlayers = {}
    end
})

ExplosionTab:AddButton({
    Name = "Remove Player",
    Callback = function()
        for playerName in pairs(selectedPlayers) do
            local username = playerName:match("^(.-) %(") or playerName
            WhitelistedPlayers[username] = nil
        end
        updateWhitelistDropdown()
        updatePlayerDropdown()
        selectedPlayers = {}
    end
})

game.Players.PlayerAdded:Connect(updatePlayerDropdown)
game.Players.PlayerRemoving:Connect(updatePlayerDropdown)

local function spawnSnowball()
    local targetPlayerName = next(selectedPlayers)
    local targetPlayer = getTargetPlayer(targetPlayerName)

    if targetPlayer then
        local targetCharacter = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
        local targetRootPart = targetCharacter:WaitForChild("HumanoidRootPart")
        
        local spawnPosition = rootPart.CFrame * CFrame.new(0, 0, 10)

        local args = {
            [1] = "BallSnowball",
            [2] = spawnPosition,
            [3] = Vector3.new(0, 65.388, 0)
        }

        local toy = ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(unpack(args))


        local spawnedInToys = workspace:FindFirstChild(player.Name .. "SpawnedInToys")
        local snowball = spawnedInToys:FindFirstChild("BallSnowball")

        if snowball and snowball:FindFirstChild("SoundPart") then
            local args = {
                [1] = snowball.SoundPart,
                [2] = snowball.SoundPart.CFrame
            }

            ReplicatedStorage.GrabEvents.SetNetworkOwner:FireServer(unpack(args))

            task.wait(0.2)

            snowball:PivotTo(targetRootPart.CFrame)

            task.wait(0.3)

            local explodeArgs = {
                [1] = {
                    ["Radius"] = 0,
                    ["Color"] = nil,
                    ["TimeLength"] = 0,
                    ["Model"] = snowball.SoundPart,
                    ["Hitbox"] = snowball.SoundPart,
                    ["ExplodesByFire"] = false,
                    ["MaxForcePerStudSquared"] = 0,
                    ["DestroysModel"] = true,
                    ["ImpactSpeed"] = 0,
                    ["ExplodesByPointy"] = false,
                    ["Type"] = "SnowPoof",
                    ["PositionPart"] = targetRootPart
                },
                [2] = targetRootPart.Position
            }

            ReplicatedStorage.BombEvents.BombExplode:FireServer(unpack(explodeArgs))
        end
    else
        warn("Jogador alvo não encontrado!")
    end
end

ExplosionTab:AddButton({
    Name = "Loop Snowball",
    Callback = function()
        spawnSnowball()
    end
})

ExplosionTab:AddButton({
	Name = "Destroy Barrier [House]",
	Callback = function()
local plots = workspace.Plots
local destruir = true  
for i = 1, 5 do
    plots["Plot" .. i].Barrier:destroy()
    plots["Plot" .. i].PlotArea:destroy()
end
  	end    
})
  	end    
})



local selectedPlayer = nil
local bombLoopActive = false
local PlayerDropdown 

local Players = game:GetService("Players")


local function getPlayers()
    local players = {}
    for _, player in pairs(Players:GetPlayers()) do
        table.insert(players, player.Name .. " (" .. player.DisplayName .. ").") 
    end
    return players
end



PlayerDropdown = KeybindSection2:AddDropdown({
    Name = "Select a Player",
    Default = "None",
    Options = getPlayers(),
    Callback = function(Value)

        local playerName = Value:match("^(%S+) %(") 
        if playerName then
            selectedPlayer = Players:FindFirstChild(playerName)
        else
            selectedPlayer = nil
        end
    end    
})


local function updateDropdown()
    if PlayerDropdown then
        PlayerDropdown:Refresh(getPlayers(), true)
    end
end


Players.PlayerAdded:Connect(updateDropdown)
Players.PlayerRemoving:Connect(updateDropdown)


task.spawn(function()
    while task.wait(1) do
        updateDropdown()
    end
end)


local function explodePlayer(player)
    if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then 
        return 
    end
    
    if #bombList == 0 then 
        OrionLib:MakeNotification({
            Name = "No Bombs",
            Content = "There are no bombs stored to explode.",
            Image = "rbxassetid://4483345998",
            Time = 2
        })
        return
    end

    local char = player.Character
    local position = char.HumanoidRootPart.Position 

    for i = #bombList, 1, -1 do
        local bomb = table.remove(bombList, i)
        local args = {
            [1] = {
                ["Radius"] = 10, 
                ["TimeLength"] = 2,
                ["Hitbox"] = bomb.PartHitDetector,
                ["ExplodesByFire"] = false,
                ["MaxForcePerStudSquared"] = 225,
                ["Model"] = bomb,
                ["ImpactSpeed"] = 100,
                ["ExplodesByPointy"] = false,
                ["DestroysModel"] = false,
                ["PositionPart"] = char.HumanoidRootPart
            },
            [2] = position
        }
        ReplicatedStorage:WaitForChild("BombEvents"):WaitForChild("BombExplode"):FireServer(unpack(args))
    end
end


KeybindSection2:AddToggle({
    Name = "Loop Explosion Target",
    Default = false,
    Callback = function(Value)
        bombLoopActive = Value
        if bombLoopActive then
            task.spawn(function()
                while bombLoopActive do
                    if selectedPlayer then
                        explodePlayer(selectedPlayer)
                    end
                    task.wait(0.5) 
                end
            end)
        end
    end    
})


local KeybindSection2 = KeybindsTab:AddSection({Name = "Explosion All"})

local bombLoopActive = false
local localPlayer = game:GetService("Players").LocalPlayer


local function getPlayers()
    local players = {}
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= localPlayer and player.Character then
            table.insert(players, player)
        end
    end
    return players
end


local function explodeCharacter(character)
    if not character or not character:FindFirstChild("HumanoidRootPart") then 
        return 
    end
    
    if #bombList == 0 then 
        OrionLib:MakeNotification({
            Name = "No Bombs",
            Content = "There are no bombs stored to explode.",
            Image = "rbxassetid://4483345998",
            Time = 2
        })
        return
    end

    local position = character.HumanoidRootPart.Position

    for i = #bombList, 1, -1 do
        local bomb = table.remove(bombList, i)
        local args = {
            [1] = {
                ["Radius"] = 10,
                ["TimeLength"] = 2,
                ["Hitbox"] = bomb.PartHitDetector,
                ["ExplodesByFire"] = false,
                ["MaxForcePerStudSquared"] = 225,
                ["Model"] = bomb,
                ["ImpactSpeed"] = 100,
                ["ExplodesByPointy"] = false,
                ["DestroysModel"] = false,
                ["PositionPart"] = character.HumanoidRootPart
            },
            [2] = position
        }
        ReplicatedStorage:WaitForChild("BombEvents"):WaitForChild("BombExplode"):FireServer(unpack(args))
    end
end


KeybindSection2:AddToggle({
    Name = "Loop Explosion [All]",
    Default = false,
    Callback = function(Value)
        bombLoopActive = Value
        if bombLoopActive then
            task.spawn(function()
                while bombLoopActive do
                    local players = getPlayers()
                    for _, player in pairs(players) do
                        if not bombLoopActive then return end 
                        explodeCharacter(player.Character)
                        task.wait(0.5) 
                    end
                    task.wait(0.5) 
                end
            end)
        end
    end    
})

ExplosionTab:AddDropdown({
	Name = "Toy to load",
	Default = "BombMissile",
	Options = {"BombMissile"},
	Callback = function(Value)
		_G.ToyToLoad = Value
	end    
})
ExplosionTab:AddSlider({
    Name = "Max amount of missiles",
    Min = 1,
    Max = localPlayer.ToysLimitCap.Value / 10,
    Color = Color3.fromRGB(240, 0, 0),
    ValueName = "Missiles",
    Increment = 1,
    Default = _G.MaxMissiles,
    Save = true,
    Flag = "NaxMissilesSlider",
    Callback = function(value)
        _G.MaxMissiles = value
    end
})

ExplosionTab:AddToggle({
    Name = "Auto Reload Cache",
    Default = false,
    Color = Color3.fromRGB(240, 0, 0),
    Save = true,
    Flag = "AutoReloadBombs",
    Callback = function(enabled)
       reloadMissile(enabled)
    end
})

local lineTab = Window:MakeTab({
    Name = "Line Crazy",
    Icon = "rbxassetid://7733954884"
})



local Section = lineTab:AddSection({
	Name = "Invisible Line And Lag All And Double Grab"
})

lineTab:AddButton({
	Name = "Invisible Line and Lag All and Double Grab",
	Callback = function()
local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/ionlyusegithubformcmods/1-Line-Scripts/main/Mobile%20Friendly%20Orion')))() 

local Window = OrionLib:MakeWindow({Name = "Line Crazy", HidePremium = false, SaveConfig = true, ConfigFolder = "OrionTest"})

local lineTab = Window:MakeTab({
	Name = "Tab 1",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})

local Section = lineTab:AddSection({
	Name = "Double Grab"
})

lineTab:AddButton({
	Name = "Double Grab",
	Callback = function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

if character then
    local grabbingScript = character:FindFirstChild("GrabbingScript")
    if grabbingScript then
        local clonedScript = grabbingScript:Clone()
        clonedScript.Parent = character
    end
    
    local indexx = character:FindFirstChild("Indexx")
    if indexx then
        local clonedIndexx = indexx:Clone()
        clonedIndexx.Parent = character
    end
end
  	end    
})

local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local isLooping = false

lineTab:AddToggle({
    Name = "Invisible Line",
    Default = false,
    Callback = function(Value)
        if Value then
            if isLooping then return end  
            isLooping = true
            
            task.spawn(function()
                RunService:BindToRenderStep("CreateGrabLine", Enum.RenderPriority.First.Value, function()
                    if not isLooping then
                        RunService:UnbindFromRenderStep("CreateGrabLine")
                        return
                    end
                    ReplicatedStorage.GrabEvents.CreateGrabLine:FireServer()
                end)
            end)

        else
            isLooping = false
            RunService:UnbindFromRenderStep("CreateGrabLine")
        end
    end    
})

local Section = lineTab:AddSection({
    Name = "Lag"
})




local lagEnabled = false
local lagStrength = 1000 
local lagSpeed = 0  

lineTab:AddToggle({
    Name = "Lag All (Normal Mode)",
    Default = false,
    Callback = function(Value)
        lagEnabled = Value
        if lagEnabled then
            spawn(function()
                while lagEnabled do
                    for i = 1, lagStrength do
                        game:GetService("ReplicatedStorage").GrabEvents.CreateGrabLine:FireServer(workspace:FindFirstChildOfClass("Part"), CFrame.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)))
                    end
                    wait(1 * lagSpeed)  
                end
            end)
        end
    end
})

lineTab:AddSlider({
    Name = "Lag Force",
    Min = 100,
    Max = 10000,
    Default = 10000,
    Color = Color3.fromRGB(255, 105, 180),
    Increment = 100,
    ValueName = "Força",
    Callback = function(Value)
        lagStrength = Value
    end
})

lineTab:AddSlider({
    Name = "Speed Lag",
    Min = 0,
    Max = 1,
    Default = 0,
    Color = Color3.fromRGB(0, 255, 0),
    Increment = 0.01,
    ValueName = "Velocidade",
    Callback = function(Value)
        lagSpeed = Value
    end
})


local Section = lineTab:AddSection({
    Name = "Lag Players"
})



local Players = game:GetService("Players")
local GrabEvents = game:GetService("ReplicatedStorage").GrabEvents  

local enableGrabLine = false
local running = false
local lineCreationSpeed = 1  

local function createGrabLineForAll()
    while running do
        for _, player in ipairs(Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("Torso") then
                local args = {
                    [1] = player.Character.Torso,
                    [2] = CFrame.new(0.44449615478515625, 0.9501018524169922, 0.5) * CFrame.Angles(0, -1.2647119760513306, 0)
                }
                GrabEvents.CreateGrabLine:FireServer(unpack(args))
            end
        end
        wait(lineCreationSpeed)  
    end
end

local function removeAllGrabLines()
    local args = {
        [1] = workspace
    }
    GrabEvents.DestroyGrabLine:FireServer(unpack(args))
end

lineTab:AddToggle({
    Name = "Lag All (create lines on all players)",
    Default = false,
    Callback = function(Value)
        enableGrabLine = Value
        if enableGrabLine then
            print("Linhas de captura ativadas!")
            running = true
            createGrabLineForAll()
        else
            print("Linhas de captura desativadas!")
            running = false
            removeAllGrabLines() 
        end
    end    
})

lineTab:AddSlider({
    Name = "Speed Lag",
    Min = 0,    
    Max = 10,
    Default = 1,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 0.1,
    ValueName = "Velocity",
    Callback = function(Value)
        lineCreationSpeed = Value  
        print("Velocidade de criação de linhas: " .. tostring(lineCreationSpeed))
    end
})



local Section = lineTab:AddSection({
    Name = "Lag Objects "
})

local Workspace = game:GetService("Workspace")
local GrabEvents = game:GetService("ReplicatedStorage").GrabEvents  

local enableGrabLine = false
local running = false
local lineCreationSpeed = 1  

local function createGrabLineForWorkspace()
    while running do
        for _, object in ipairs(Workspace:GetChildren()) do
            if object:IsA("BasePart") or object:IsA("Model") then  -- Verifica se o objeto é uma parte ou um modelo
                local args = {
                    [1] = object,
                    [2] = CFrame.new(0.44449615478515625, 0.9501018524169922, 0.5) * CFrame.Angles(0, -1.2647119760513306, 0)
                }
                GrabEvents.CreateGrabLine:FireServer(unpack(args))
            end
        end
        wait(lineCreationSpeed)  
    end
end

local function removeAllGrabLines()
    local args = {
        [1] = Workspace
    }
    GrabEvents.DestroyGrabLine:FireServer(unpack(args))
end

lineTab:AddToggle({
    Name = "Lag all (Create line In all objects)",
    Default = false,
    Callback = function(Value)
        enableGrabLine = Value
        if enableGrabLine then
            print("Snap lines enabled for all objects in the Workspace!")
            running = true
            createGrabLineForWorkspace()  
        else
            print("Linhas de captura desativadas!")
            running = false
            removeAllGrabLines()  
        end
    end    
})

lineTab:AddSlider({
    Name = "Speed Lag",
    Min = 0,     
    Max = 10,
    Default = 1,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 0.1,
    ValueName = "Velocity",
    Callback = function(Value)
        lineCreationSpeed = Value  
        print("Velocidade de criação de linhas: " .. tostring(lineCreationSpeed))
    end
})

  	end    
})



local BlobmanTab = Window:MakeTab({Name = "Blobman", Icon =  "rbxassetid://7733916988", PremiumOnly = false})

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local Player = Players.LocalPlayer

local dropping, creatureBlobman, dropCoroutine = false, nil, nil

local function findCreatureBlobman()
    local spawnedInToys = Workspace:FindFirstChild(Player.Name .. "SpawnedInToys")
    creatureBlobman = spawnedInToys and spawnedInToys:FindFirstChild("CreatureBlobman") or nil
end

local function dropAllPlayers()
    if not creatureBlobman then findCreatureBlobman() end
    if not creatureBlobman then return end

    for _, target in ipairs(Players:GetPlayers()) do
        local root = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
        if root then
            for _, weld in ipairs({creatureBlobman.LeftDetector.LeftWeld, creatureBlobman.RightDetector.RightWeld}) do
                creatureBlobman.BlobmanSeatAndOwnerScript.CreatureDrop:FireServer(weld, root)
            end
        end
    end
end

local function startDropping()
    if dropCoroutine and coroutine.status(dropCoroutine) ~= "dead" then return end
    dropCoroutine = coroutine.create(function()
        while dropping do
            dropAllPlayers()
            task.wait()
        end
    end)
    coroutine.resume(dropCoroutine)
end

BlobmanTab:AddToggle({
    Name = "Loop Drop (On Blobman)",
    Default = false,
    Callback = function(Value)
        dropping = Value
        if dropping then
            startDropping()
        end
    end    
})

Player.CharacterAdded:Connect(function()
    task.wait(1)
    findCreatureBlobman()
    if dropping then
        startDropping()
    end
end)

local blobman1
blobman1 = BlobmanTab:AddToggle({
    Name = "Destroy All (Server)",
    Color = Color3.fromRGB(240, 0, 0),
    Default = false,
    Callback = function(enabled)
        if enabled then
            print("Toggle enabled")
            blobmanCoroutine = coroutine.create(function()
                local foundBlobman = false
                for i, v in pairs(game.Workspace:GetDescendants()) do
                    if v.Name == "CreatureBlobman" then
                        print("Found CreatureBlobman")
                        if v:FindFirstChild("VehicleSeat") and v.VehicleSeat:FindFirstChild("SeatWeld") and isDescendantOf(v.VehicleSeat.SeatWeld.Part1, localPlayer.Character) then
                            print("Mounted on blobman")
                            blobman = v
                            foundBlobman = true
                            break
                        end
                    end
                end
                print("Out of the loop!")
 
                if not foundBlobman then
                    print("No mount found")
                    OrionLib:MakeNotification({
                        Name = "Error",
                        Content = "You must be mounted upon a blobman to begin this process. Please mount one and toggle this again!", 
                        Image = "rbxassetid://4483345998", 
                        Time = 5
                    })
                    blobman1:Set(false)
                    blobman = nil
                    coroutine.close(blobmanCoroutine)
                    blobmanCoroutine = nil
                    return
                end
 
                while true do
                    pcall(function()
                        while wait() do
                            for i, v in pairs(Players:GetChildren()) do
                                if blobman and v ~= localPlayer then
                                    blobGrabPlayer(v, blobman)
                                    print(v.Name)
                                    wait(_G.BlobmanDelay)
                                end
                            end
                        end
                    end)
                    wait(0.02)
                end
            end)
            coroutine.resume(blobmanCoroutine)
        else
            if blobmanCoroutine then
                coroutine.close(blobmanCoroutine)
                blobmanCoroutine = nil
                blobman = nil
            end
        end
    end
})

BlobmanTab:AddSlider({
    Name = "Speed Bring",
    Min = 0,
    Max = 0.1,
    Color = Color3.fromRGB(240, 0, 0),
    ValueName = ".",
    Increment = 0.00000000001,
    Default = _G.BlobmanDelay ,
    Callback = function(value)
        _G.BlobmanDelay  = value
    end
})

local keyTab = Window:MakeTab({
	Name = "Keybinds",
	Icon = "rbxassetid://7733799901",
	PremiumOnly = false
})

local Player = game.Players.LocalPlayer
local Camera = game.Workspace.CurrentCamera

local TELEPORT_DISTANCE_LIMIT = 150

local TeleportGUI

local function getSafePosition(position)
    local rayOrigin = position + Vector3.new(0, 5, 0)
    local rayDirection = Vector3.new(0, -50, 0)

    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {Player.Character}
    params.FilterType = Enum.RaycastFilterType.Blacklist

    local result = workspace:Raycast(rayOrigin, rayDirection, params)

    if result then
        return Vector3.new(position.X, result.Position.Y + 3, position.Z)
    else
        return position
    end
end

local function teleportPlayer()
    local character = Player.Character or Player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    if not humanoidRootPart then return end

    local direction = Camera.CFrame.LookVector
    local newPosition = humanoidRootPart.Position + (direction.Unit * TELEPORT_DISTANCE_LIMIT)
    newPosition = getSafePosition(newPosition)

    humanoidRootPart.CFrame = CFrame.new(newPosition)
end

local function createTeleportGUI()
    if TeleportGUI then return end

    TeleportGUI = Instance.new("ScreenGui")
    TeleportGUI.Parent = game.CoreGui  

    local Button = Instance.new("TextButton")
    Button.Parent = TeleportGUI
    Button.Size = UDim2.new(0, 100, 0, 100)
    Button.Position = UDim2.new(0, 624.728, 0, 294.259)
    Button.Text = "Teleport"
    Button.BackgroundTransparency = 0.4
    Button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextTransparency = 0.2

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(1, 0)
    UICorner.Parent = Button

    Button.MouseButton1Click:Connect(teleportPlayer)
end

local function destroyTeleportGUI()
    if TeleportGUI then
        TeleportGUI:Destroy()
        TeleportGUI = nil
    end
end

keyTab:AddToggle({
    Name = "Teleport GUI",
    Default = false,
    Callback = function(Value)
        if Value then
            createTeleportGUI()
            OrionLib:MakeNotification({
                Name = "Teleport GUI Activated",
                Content = "The teleport button is now visible!",
                Image = "rbxassetid://4483345998",
                Time = 3
            })
        else
            destroyTeleportGUI()
            OrionLib:MakeNotification({
                Name = "Teleport GUI Deactivated",
                Content = "The teleport button has been removed!",
                Image = "rbxassetid://4483345998",
                Time = 3
            })
        end
    end
})

local Player = game.Players.LocalPlayer
local Camera = game.Workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")

local function teleportPlayer()
    local cameraPosition = Camera.CFrame.Position
    local cameraDirection = Camera.CFrame.LookVector
    local teleportDistance = 50
    local targetPosition = cameraPosition + cameraDirection * teleportDistance

    local rayOrigin = cameraPosition
    local rayDirection = cameraDirection * teleportDistance

    local raycastResult = workspace:Raycast(rayOrigin, rayDirection)

    if raycastResult then
        targetPosition = raycastResult.Position
    end

    local character = Player.Character or Player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoidRootPart.CFrame = CFrame.new(targetPosition)
end

local teleportEnabled = false

local Section = keyTab:AddSection({
	Name = "Computer Version"
})

keyTab:AddBind({
    Name = "Teleport Bind",
    Default = Enum.KeyCode.N,
    Hold = false,
    Callback = function()
        teleportEnabled = not teleportEnabled
    end    
})

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if teleportEnabled and input.KeyCode == Enum.KeyCode.N then
        teleportPlayer()
        teleportEnabled = false  
        OrionLib:MakeNotification({
            Name = "Teleport Mode",
            Content = "Disabled",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
end)







local auraTab = Window:MakeTab({
	Name = "Aura V2 (So it doesn't bug)",
	Icon = "rbxassetid://7733666258",
	PremiumOnly = false
})

local freezeAuraEnabled = false

auraTab:AddToggle({
    Name = "Freeze Aura",
    Default = false,
    Callback = function(value)
        freezeAuraEnabled = value
    end
})

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

local event = game:GetService("ReplicatedStorage"):FindFirstChild("GrabEvents")
local setNetworkOwner = event and event:FindFirstChild("SetNetworkOwner")

local function freezePlayer(targetPlayer)
    local targetChar = targetPlayer.Character
    if targetChar then
        local part = targetChar:FindFirstChild("HumanoidRootPart")
        if part then
            part.CanCollide = false
            for _, desc in pairs(targetChar:GetChildren()) do
                if desc:IsA("BasePart") then
                    desc.CanCollide = false
                end
            end

            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            bodyVelocity.Parent = part

            game.Debris:AddItem(bodyVelocity, 0.1)
        end
    end
end

local function processPlayers()
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player then
            local otherChar = otherPlayer.Character
            if otherChar then
                local part = otherChar:FindFirstChild("HumanoidRootPart")
                if part then
                    local distance = (rootPart.Position - part.Position).Magnitude
                    if distance <= 20 then
                        setNetworkOwner:FireServer(part, part.CFrame)
                        freezePlayer(otherPlayer)
                    end
                end
            end
        end
    end
end

game:GetService("RunService").Stepped:Connect(function()
    if freezeAuraEnabled then
        processPlayers()
    end
end)



local infernoAuraAtivo = false

auraTab:AddToggle({
    Name = "Kill Aura",
    Default = false,
    Callback = function(valor)
        infernoAuraAtivo = valor
    end
})

local jogador = game.Players.LocalPlayer
local personagem = jogador.Character or jogador.CharacterAdded:Wait()
local raiz = personagem:WaitForChild("HumanoidRootPart")

local evento = game:GetService("ReplicatedStorage"):FindFirstChild("GrabEvents")
local definirDonoRede = evento and evento:FindFirstChild("SetNetworkOwner")

local function enviarParaVoid(alvoJogador)
    local alvoChar = alvoJogador.Character
    if alvoChar then
        local parte = alvoChar:FindFirstChild("HumanoidRootPart")
        if parte then
            parte.CanCollide = false
            for _, obj in pairs(alvoChar:GetChildren()) do
                if obj:IsA("BasePart") then
                    obj.CanCollide = false
                end
            end

            local velocidade = Instance.new("BodyVelocity")
            velocidade.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            velocidade.Velocity = Vector3.new(0, -1000, 0)
            velocidade.Parent = parte

            game.Debris:AddItem(velocidade, 0.1)
        end
    end
end

local function lidarComJogadores()
    for _, outroJogador in pairs(game.Players:GetPlayers()) do
        if outroJogador ~= jogador then
            local outroChar = outroJogador.Character
            if outroChar then
                local parte = outroChar:FindFirstChild("HumanoidRootPart")
                if parte then
                    local distancia = (raiz.Position - parte.Position).Magnitude
                    if distancia <= 20 then
                        definirDonoRede:FireServer(parte, parte.CFrame)
                        enviarParaVoid(outroJogador)
                    end
                end
            end
        end
    end
end

game:GetService("RunService").Stepped:Connect(function()
    if infernoAuraAtivo then
        lidarComJogadores()
    end
end)

local spyAuraEnabled = false

auraTab:AddToggle({
    Name = "Spy Aura",
    Default = false,
    Callback = function(value)
        spyAuraEnabled = value
    end
})

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

local event = game:GetService("ReplicatedStorage"):FindFirstChild("GrabEvents")
local setNetworkOwner = event and event:FindFirstChild("SetNetworkOwner")

local function spyOnPlayer(targetPlayer)
    local targetChar = targetPlayer.Character
    if targetChar then
        local part = targetChar:FindFirstChild("HumanoidRootPart")
        if part then
            part.CanCollide = false
            for _, desc in pairs(targetChar:GetChildren()) do
                if desc:IsA("BasePart") then
                    desc.CanCollide = false
                end
            end

            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.Velocity = Vector3.new(0, 1000, 0)
            bodyVelocity.Parent = part

            game.Debris:AddItem(bodyVelocity, 0.1)
        end
    end
end

local function monitorPlayers()
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player then
            local otherChar = otherPlayer.Character
            if otherChar then
                local part = otherChar:FindFirstChild("HumanoidRootPart")
                if part then
                    local distance = (rootPart.Position - part.Position).Magnitude
                    if distance <= 20 then
                        setNetworkOwner:FireServer(part, part.CFrame)
                        spyOnPlayer(otherPlayer)
                    end
                end
            end
        end
    end
end

game:GetService("RunService").Stepped:Connect(function()
    if spyAuraEnabled then
        monitorPlayers()
    end
end)


local deathAuraEnabled = false

auraTab:AddToggle({
    Name = "Death Aura",
    Default = false,
    Callback = function(value)
        deathAuraEnabled = value
    end
})

local player = game.Players.LocalPlayer

local function setupCharacter()
    local character = player.Character or player.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    local event = game:GetService("ReplicatedStorage"):FindFirstChild("GrabEvents")
    local setNetworkOwner = event and event:FindFirstChild("SetNetworkOwner")

    local function sendToVoid(targetPlayer)
        local targetChar = targetPlayer.Character
        if targetChar then
            local part = targetChar:FindFirstChild("HumanoidRootPart")
            if part then
                -- Disable collision for all parts of the target character
                part.CanCollide = false
                for _, desc in pairs(targetChar:GetChildren()) do
                    if desc:IsA("BasePart") then
                        desc.CanCollide = false
                    end
                end

                -- Set PlatformStand to true to immobilize the humanoid
                local humanoid = targetChar:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid.PlatformStand = true
                end

                -- Apply BodyVelocity to push the player downwards
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyVelocity.Velocity = Vector3.new(0, -1000, 0)  -- Push the player downwards
                bodyVelocity.Parent = part

                -- Apply a BodyGyro to lock the player's orientation
                local bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                bodyGyro.CFrame = part.CFrame
                bodyGyro.Parent = part

                -- Remove the BodyVelocity and BodyGyro after a short period
                game.Debris:AddItem(bodyVelocity, 0.1)
                game.Debris:AddItem(bodyGyro, 0.1)
            end
        end
    end

    local function setPlayerAsDead(targetPlayer)
        local targetChar = targetPlayer.Character
        if targetChar then
            local humanoid = targetChar:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Dead)
                humanoid.PlatformStand = true
            end
        end
    end

    local function monitorPlayers()
        for _, otherPlayer in pairs(game.Players:GetPlayers()) do
            if otherPlayer ~= player then
                local otherChar = otherPlayer.Character
                if otherChar then
                    local part = otherChar:FindFirstChild("HumanoidRootPart")
                    if part then
                        local distance = (rootPart.Position - part.Position).Magnitude
                        if distance <= 20 then
                            setNetworkOwner:FireServer(part, part.CFrame)
                            wait(1.9)
                            sendToVoid(otherPlayer)
                            setPlayerAsDead(otherPlayer)
                            game:GetService("ReplicatedStorage"):WaitForChild("GrabEvents"):WaitForChild("DestroyGrabLine"):FireServer(part)
                        end
                    end
                end
            end
        end
    end

    game:GetService("RunService").Stepped:Connect(function()
        if deathAuraEnabled then
            monitorPlayers()
        end
    end)
end



player.CharacterAdded:Connect(setupCharacter)

if player.Character then
    setupCharacter()
end


auraTab:AddToggle({
    Name = "Poison Aura",
    Default = false,
    Color = Color3.fromRGB(240, 0, 0),
    Save = true,
    Callback = function(enabled)
        if enabled then
            poisonAuraCoroutine = coroutine.create(function()
                while enabled do
                    local success, err = pcall(function()
                        local character = localPlayer.Character
                        if character and character:FindFirstChild("HumanoidRootPart") then
                            local humanoidRootPart = character.HumanoidRootPart

                            for _, player in pairs(Players:GetPlayers()) do
                                if player ~= localPlayer and player.Character then
                                    local playerCharacter = player.Character
                                    local playerTorso = playerCharacter:FindFirstChild("Torso")
                                    if playerTorso then
                                        local distance = (playerTorso.Position - humanoidRootPart.Position).Magnitude
                                        if distance <= auraRadius then
                                            local head = playerCharacter:FindFirstChild("Head")
                                            while distance <= auraRadius do
                                                SetNetworkOwner:FireServer(playerTorso, playerCharacter.HumanoidRootPart.CFrame)
                                                distance = (playerTorso.Position - humanoidRootPart.Position).Magnitude
                                                for _, part in pairs(poisonHurtParts) do
                                                    part.Size = Vector3.new(1, 3, 1)
                                                    part.Transparency = 1
                                                    part.Position = head.Position
                                                end
                                                wait()
                                                for _, part in pairs(poisonHurtParts) do
                                                    part.Position = Vector3.new(0, -200, 0)
                                                end
                                            end
                                            for _, part in pairs(poisonHurtParts) do
                                                part.Position = Vector3.new(0, -200, 0)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end)
                    if not success then
                        warn("Error in Poison Aura: " .. tostring(err))
                    end
                end
            end)
            coroutine.resume(poisonAuraCoroutine)
        elseif poisonAuraCoroutine then
            coroutine.close(poisonAuraCoroutine)
            for _, part in pairs(poisonHurtParts) do
                part.Position = Vector3.new(0, -200, 0)
            end
            poisonAuraCoroutine = nil
        end
    end
})

auraTab:AddButton({
	Name = "Aura V2",
	Callback = function()
local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/ionlyusegithubformcmods/1-Line-Scripts/main/Mobile%20Friendly%20Orion')))() 

local Window = OrionLib:MakeWindow({Name = "Aura V2", HidePremium = false, SaveConfig = true, ConfigFolder = "OrionTest"})

local GrabWhitelist = Window:MakeTab({
    Name = "Aura V2",
    Icon = "rbxassetid://7733666258",
    PremiumOnly = false
})

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TornadoParts = {}
local flungPlayers = {}
local TornadoSettings = {
    Enabled = false,
    Layers = 3,
    Speed = 50,
    Height = 10,
    MaxDistance = 40,
    FlingVelocity = 999,
    RotationSpeed = 50,
    RadiusMultiplier = 10,
    PlayerSeparation = 5,
    GrabInterval = 0.5,
    MinDistance = 5,
    ApproachSpeed = 20
}

local lastGrabTime = 0
_G.WhitelistedPlayers = _G.WhitelistedPlayers or {}

local function setNoclip(character, state)
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = not state
        end
    end
end

local function setNetworkOwner(part)
    pcall(function()
        game:GetService("ReplicatedStorage").GrabEvents.SetNetworkOwner:FireServer(part, part.CFrame)
    end)
end

local function createBodyMovers(part, targetPosition, rotation, approach)
    local existingMover = TornadoParts[part]
    if not existingMover then
        local bodyVelocity = Instance.new("BodyVelocity", part)
        bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        local bodyGyro = Instance.new("BodyGyro", part)
        bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        TornadoParts[part] = {Velocity = bodyVelocity, Gyro = bodyGyro}
    else
        if approach then
            existingMover.Velocity.Velocity = (targetPosition - part.Position).Unit * TornadoSettings.ApproachSpeed
        else
            existingMover.Velocity.Velocity = (targetPosition - part.Position).Unit * TornadoSettings.Speed
        end
        existingMover.Gyro.CFrame = rotation
    end
end

local function flingPlayer(part)
    if TornadoParts[part] then
        TornadoParts[part].Velocity:Destroy()
        TornadoParts[part].Gyro:Destroy()
        TornadoParts[part] = nil
    end
    local bodyVelocity = Instance.new("BodyVelocity", part)
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(math.random(-TornadoSettings.FlingVelocity, TornadoSettings.FlingVelocity), TornadoSettings.FlingVelocity, math.random(-TornadoSettings.FlingVelocity, TornadoSettings.FlingVelocity))
    game:GetService("Debris"):AddItem(bodyVelocity, 1)
end

local function tornadoEffect()
    local localCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local localRoot = localCharacter:WaitForChild("HumanoidRootPart")
    local playerPos = localRoot.Position
    local players = Players:GetPlayers()
    local validPlayers = {}

    for _, player in ipairs(players) do
        if (player ~= LocalPlayer and player.Character and not _G.WhitelistedPlayers[player.Name]) then
            local otherRoot = player.Character:FindFirstChild("HumanoidRootPart")
            if (otherRoot and ((otherRoot.Position - playerPos).Magnitude <= TornadoSettings.MaxDistance)) then
                table.insert(validPlayers, player)
                setNoclip(player.Character, true)
            end
        end
    end

    local angleOffset = 360 / #validPlayers
    for i, player in ipairs(validPlayers) do
        local otherRoot = player.Character:FindFirstChild("HumanoidRootPart")
        if not flungPlayers[player] then
            setNetworkOwner(otherRoot)
            local distanceToPlayer = (otherRoot.Position - playerPos).Magnitude
            local separationAngle = (i - 1) * angleOffset
            local separationRadius = TornadoSettings.PlayerSeparation * (i - 1)
            local baseX = playerPos.X + (separationRadius * math.cos(math.rad(separationAngle)))
            local baseZ = playerPos.Z + (separationRadius * math.sin(math.rad(separationAngle)))
            local approach = distanceToPlayer > TornadoSettings.MinDistance

            for j = 1, TornadoSettings.Layers do
                local angle = (tick() * TornadoSettings.RotationSpeed) + separationAngle + (j * (360 / TornadoSettings.Layers))
                local radius = (j * TornadoSettings.RadiusMultiplier) + separationRadius
                local posX, posZ
                
                if approach then
                    local direction = (playerPos - otherRoot.Position).Unit
                    local offset = direction * TornadoSettings.MinDistance
                    posX = playerPos.X - offset.X
                    posZ = playerPos.Z - offset.Z
                else
                    posX = baseX + (radius * math.cos(math.rad(angle)))
                    posZ = baseZ + (radius * math.sin(math.rad(angle)))
                end
                
                local posY = playerPos.Y + ((j * TornadoSettings.Height) / TornadoSettings.Layers)
                local targetPosition = Vector3.new(posX, posY, posZ)
                local rotation = CFrame.Angles(0, math.rad(angle), 0)
                createBodyMovers(otherRoot, targetPosition, rotation, approach)
            end
        end
    end
end

local function clearBodyMovers()
    if ((tick() - lastGrabTime) >= TornadoSettings.GrabInterval) then
        for part, _ in pairs(TornadoParts) do
            if not flungPlayers[Players:GetPlayerFromCharacter(part.Parent)] then
                flingPlayer(part)
                flungPlayers[Players:GetPlayerFromCharacter(part.Parent)] = true
            end
        end
        TornadoParts = {}
        lastGrabTime = tick()
    end
end

RunService.Heartbeat:Connect(function()
    if TornadoSettings.Enabled then
        tornadoEffect()
    else
        clearBodyMovers()
        flungPlayers = {}
    end
end)

GrabWhitelist:AddSection({ Name = "Tornado Players" })

GrabWhitelist:AddToggle({
    Name = "Enable Tornado",
    Default = false,
    Callback = function(value)
        TornadoSettings.Enabled = value
        if not value then
            clearBodyMovers()
            flungPlayers = {}
        end
    end
})

GrabWhitelist:AddSlider({
    Name = "Tornado Layers",
    Min = 1,
    Max = 10,
    Default = 3,
    Callback = function(value)
        TornadoSettings.Layers = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Tornado Speed",
    Min = 1,
    Max = 100,
    Default = 50,
    Callback = function(value)
        TornadoSettings.Speed = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Tornado Height",
    Min = 1,
    Max = 50,
    Default = 10,
    Callback = function(value)
        TornadoSettings.Height = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Max Distance",
    Min = 10,
    Max = 100,
    Default = 40,
    Callback = function(value)
        TornadoSettings.MaxDistance = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Rotation Speed",
    Min = 1,
    Max = 100,
    Default = 50,
    Callback = function(value)
        TornadoSettings.RotationSpeed = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Min Distance to Player",
    Min = 1,
    Max = 20,
    Default = 5,
    Callback = function(value)
        TornadoSettings.MinDistance = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Approach Speed",
    Min = 1,
    Max = 50,
    Default = 20,
    Callback = function(value)
        TornadoSettings.ApproachSpeed = value
    end
})

GrabWhitelist:AddSection({ Name = "Tornado Objects" })

_G.TornadoConfig = {
    isMoving = false,
    orbitSpeed = 10,
    updateInterval = 0.1,
    layerCount = 5,
    layerSpacing = 4,
    layerRadius = 5,
    baseRadius = 10,
    baseHeight = 2,
    heightIncrement = 2,
    xSpinSpeed = 5,
    ySpinSpeed = 5,
    heightOffset = 0,
    tornadoRadius = 20
}

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local activeToys = {}
local effectConnection
local lastUpdateTime = 0

local function createBodyMovers(part, position, rotation)
    local bodyPosition = part:FindFirstChild("BodyPosition") or Instance.new("BodyPosition", part)
    bodyPosition.P = 2000
    bodyPosition.D = 400
    bodyPosition.MaxForce = Vector3.new(5000000, 5000000, 5000000)
    bodyPosition.Position = position

    local bodyGyro = part:FindFirstChild("BodyGyro") or Instance.new("BodyGyro", part)
    bodyGyro.P = 2000
    bodyGyro.D = 400
    bodyGyro.MaxTorque = Vector3.new(5000000, 5000000, 5000000)
    bodyGyro.CFrame = rotation

    part.Anchored = false
end

local function disableCollision(model)
    for _, part in pairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end

local function enableCollision(model)
    for _, part in pairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

local function addToysToTornado()
    for _, toy in ipairs(Workspace:GetDescendants()) do
        if toy:IsA("Model") and toy:FindFirstChild("SoundPart") and not activeToys[toy] then
            local randomLayer = math.random(1, _G.TornadoConfig.layerCount)
            activeToys[toy] = {
                angleOffset = math.random(0, 360),
                xOffset = math.random(0, 360),
                yOffset = math.random(0, 360),
                layer = randomLayer
            }
            disableCollision(toy)
        end
    end
end

local function clearToys()
    for toy, _ in pairs(activeToys) do
        local soundPart = toy:FindFirstChild("SoundPart")
        if soundPart then
            for _, child in ipairs(soundPart:GetChildren()) do
                if child:IsA("BodyMover") or child:IsA("BodyGyro") then
                    child:Destroy()
                end
            end
            enableCollision(toy)
        end
    end
    activeToys = {}
end

local function tornadoEffect()
    local character = player.Character
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    for toy, data in pairs(activeToys) do
        local soundPart = toy:FindFirstChild("SoundPart")
        if soundPart then
            local layer = data.layer
            local layerRadius = _G.TornadoConfig.baseRadius + ((layer - 1) * _G.TornadoConfig.layerRadius)
            local layerHeight = _G.TornadoConfig.baseHeight + ((layer - 1) * _G.TornadoConfig.heightIncrement)

            data.angleOffset = (data.angleOffset + (_G.TornadoConfig.orbitSpeed * _G.TornadoConfig.updateInterval)) % 360
            data.xOffset = (data.xOffset + (_G.TornadoConfig.xSpinSpeed * _G.TornadoConfig.updateInterval)) % 360
            data.yOffset = (data.yOffset + (_G.TornadoConfig.ySpinSpeed * _G.TornadoConfig.updateInterval)) % 360

            local angle = math.rad(data.angleOffset)
            local xSpin = math.rad(data.xOffset)
            local ySpin = math.rad(data.yOffset)

            local posX = rootPart.Position.X + (_G.TornadoConfig.tornadoRadius * math.cos(angle) * math.cos(xSpin))
            local posZ = rootPart.Position.Z + (_G.TornadoConfig.tornadoRadius * math.sin(angle) * math.sin(ySpin))
            local posY = rootPart.Position.Y + (layer * _G.TornadoConfig.layerSpacing) + layerHeight + _G.TornadoConfig.heightOffset

            createBodyMovers(soundPart, Vector3.new(posX, posY, posZ), CFrame.Angles(xSpin, angle, ySpin))
        end
    end
end

local function toggleEffect()
    if _G.TornadoConfig.isMoving then
        addToysToTornado()
        if effectConnection then effectConnection:Disconnect() end
        
        effectConnection = RunService.Heartbeat:Connect(function()
            if (os.clock() - lastUpdateTime) >= _G.TornadoConfig.updateInterval then
                lastUpdateTime = os.clock()
                tornadoEffect()
            end
        end)
    else
        if effectConnection then effectConnection:Disconnect() end
        clearToys()
    end
end



GrabWhitelist:AddToggle({
    Name = "Enable Tornado",
    Default = false,
    Callback = function(state)
        _G.TornadoConfig.isMoving = state
        toggleEffect()
    end
})

GrabWhitelist:AddSlider({
    Name = "Orbit Speed",
    Min = 1,
    Max = 90000,
    Default = 10,
    Callback = function(value)
        _G.TornadoConfig.orbitSpeed = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Layer Count",
    Min = 1,
    Max = 3000,
    Default = 5,
    Callback = function(value)
        _G.TornadoConfig.layerCount = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Layer Spacing",
    Min = 1,
    Max = 3000,
    Default = 4,
    Callback = function(value)
        _G.TornadoConfig.layerSpacing = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Base Radius",
    Min = 5,
    Max = 3000,
    Default = 10,
    Callback = function(value)
        _G.TornadoConfig.baseRadius = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Height Increment",
    Min = 1,
    Max = 30000,
    Default = 2,
    Callback = function(value)
        _G.TornadoConfig.heightIncrement = value
    end
})

GrabWhitelist:AddSlider({
    Name = "X Spin Speed",
    Min = 1,
    Max = 3000,
    Default = 5,
    Callback = function(value)
        _G.TornadoConfig.xSpinSpeed = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Y Spin Speed",
    Min = 1,
    Max = 3000,
    Default = 5,
    Callback = function(value)
        _G.TornadoConfig.ySpinSpeed = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Height Offset",
    Min = -50,
    Max = 30000,
    Default = 0,
    Callback = function(value)
        _G.TornadoConfig.heightOffset = value
    end
})

GrabWhitelist:AddSlider({
    Name = "Tornado Radius",
    Min = 10,
    Max = 9000,
    Default = 20,
    Callback = function(value)
        _G.TornadoConfig.tornadoRadius = value
    end
})
  	end    
})


loopTab = Window:MakeTab({
    Name = "loop",
	Icon = "rbxassetid://7743869612",
    PremiumOnly = false
})

loopTab:AddSection({
	Name = "Loop Radgoll"
})


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local localPlayer = Players.LocalPlayer
local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()

localPlayer.CharacterAdded:Connect(function(character)
    playerCharacter = character
end)

local toysFolder = workspace:FindFirstChild(localPlayer.Name.."SpawnedInToys")
local ownedToys = {}
_G.ToyToLoad = "BombMissile"

local function spawnItem(itemName, position)
    task.spawn(function()
        local cframe = CFrame.new(position)
        local rotation = Vector3.new(0, 90, 0)
        ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(itemName, cframe, rotation)
    end)
end

local ragdollCoroutine
local isRagdollActive = false

local function ragdollPlayer(player)
    while isRagdollActive do
        local success, err = pcall(function()
            if not toysFolder:FindFirstChild("FoodBanana") then
                spawnItem("FoodBanana", Vector3.new(-72.9304581, -5.96906614, -265.543732))
            end
            local banana = toysFolder:WaitForChild("FoodBanana")
            local bananaPeel

            for _, part in pairs(banana:GetChildren()) do
                if part.Name == "BananaPeel" and part:FindFirstChild("TouchInterest") then
                    part.Size = Vector3.new(10, 10, 10)
                    part.Transparency = 1
                    bananaPeel = part
                    break
                end
            end

            local bodyPosition = Instance.new("BodyPosition")
            bodyPosition.P = 20000
            bodyPosition.Parent = banana.Main

            while isRagdollActive do
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    bananaPeel.Position = player.Character.HumanoidRootPart.Position or player.Character.Head.Position
                    bodyPosition.Position = playerCharacter.Head.Position + Vector3.new(0, 600, 0)
                end
                wait()
            end
        end)

        if not success then
            warn("Error in ragdollPlayer: " .. tostring(err))
        end
        wait()
    end
end

local playerList = {}
for _, player in pairs(Players:GetPlayers()) do
    table.insert(playerList, player.Name)
end

local selectedPlayerToAdd
local selectedPlayerToRemove
local selectedPlayers = {}





local playerDropdown = loopTab:AddDropdown({
    Name = "Select Player to Add",
    Options = playerList,
    Callback = function(player) 
        selectedPlayerToAdd = player 
    end
})

local selectedPlayersDropdown = loopTab:AddDropdown({
    Name = "Selected Players",
    Options = {},
    Callback = function(player) 
        selectedPlayerToRemove = player 
    end
})

local function updatePlayerDropdown()
    local playerOptions = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and not selectedPlayers[player.Name] then
            local displayOption = player.Name .. " (" .. player.DisplayName .. ")"
            table.insert(playerOptions, displayOption)
        end
    end
    playerDropdown:Refresh(playerOptions, true)
end

local function updateSelectedPlayersDropdown()
    local playerNames = {}
    for playerName in pairs(selectedPlayers) do
        table.insert(playerNames, playerName)
    end
    selectedPlayersDropdown:Refresh(playerNames, true)
end

Players.PlayerAdded:Connect(updatePlayerDropdown)
Players.PlayerRemoving:Connect(updatePlayerDropdown)
updatePlayerDropdown()



loopTab:AddButton({
    Name = "Add Player",
    Callback = function()
        if selectedPlayerToAdd then
            local username = selectedPlayerToAdd:match("^(.-) %(") or selectedPlayerToAdd
            selectedPlayers[username] = true
            updatePlayerDropdown()
            updateSelectedPlayersDropdown()
            selectedPlayerToAdd = nil
        end
    end
})

loopTab:AddButton({
    Name = "Remove Player",
    Callback = function()
        if selectedPlayerToRemove then
            local username = selectedPlayerToRemove:match("^(.-) %(") or selectedPlayerToRemove
            selectedPlayers[username] = nil
            updatePlayerDropdown()
            updateSelectedPlayersDropdown()
            selectedPlayerToRemove = nil
        end
    end
})



loopTab:AddToggle({
    Name = "Loop Radgoll",
    Default = false,
    Save = true,
    Callback = function(enabled)
        for playerName in pairs(selectedPlayers) do
            local playerToRagdoll = Players:FindFirstChild(playerName)
            if enabled and playerToRagdoll then
                if not isRagdollActive then
                    isRagdollActive = true
                    ragdollCoroutine = coroutine.create(function()
                        ragdollPlayer(playerToRagdoll)
                    end)
                    coroutine.resume(ragdollCoroutine)
                end
            else
                isRagdollActive = false
                if ragdollCoroutine then
                    ragdollCoroutine = nil
                end
            end
        end
    end
})

loopTab:AddSection({
    Name = "Loop Kill (Vhs v6)"
})

loopTab:AddButton({
	Name = "Loop Kill (Vhs v6)",
	Callback = function()
print("start")
_G.heart = "♥"
_G.f2 = "🍇"
function printke()
    local ke = {
        {"", "", " ♥", "", ""," 🍇","🍇","🍇", " ",  "♥", "♥", "♥", "♥", " ", "", "🍇", "🍇", "🍇", "🍇"},
        {"", " ", "♥", " ", "🍇", " ", " ", "🍇 ",    "♥", " ", " ", " ", " ", " ","🍇", " ", " ", " ", " "},
        {"", " ", "♥", " ", "🍇", " ", " ", "🍇",     "♥", "♥", "♥", "♥", " ", " ","🍇", "🍇", "🍇", "🍇", " "},
        {"", " ", "♥", " ", "🍇", " ", " ", "🍇",     " ", " ", " ", "♥", " ", " ","🍇", " ", " ", " ", " "},
        {"♥", "♥", "", " ", "","🍇","🍇","🍇",       "♥", "♥", "♥", "♥", " ", " ", "🍇", "🍇", "🍇", "🍇", " "}
    }
    for _, line in ipairs(ke) do
        print(table.concat(line, " "))
    end
end
printke()
local UserInputService = game:GetService("UserInputService")
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/VerbalHubz/Verbal-Hub/refs/heads/main/Jose%20RayField'))()

	local S = {
		Players = game:GetService("Players"),
		RS = game:GetService("ReplicatedStorage"),
		RSs = game:GetService("RunService"),
		w = game:GetService("Workspace"),
		r = game:GetService("RunService"),
		d = game:GetService("Debris"),
		HS = game:GetService("HttpService"),
		UIS = game:GetService("UserInputService"),
		StarterGui = game:GetService("StarterGui")}

	local me = S.Players.LocalPlayer; local pccontrol = me.PlayerGui.ControlsGui.PCFrame

	local O = {
		Events = {
			saymsg = S.RS.DefaultChatSystemChatEvents.SayMessageRequest,
			getmsg = S.RS.DefaultChatSystemChatEvents.OnMessageDoneFiltering,
			DestroyToyEvent = S.RS.MenuToys.DestroyToy,
			SetLineColorEvent = S.RS.DataEvents.UpdateLineColorsEvent,
			ExtendLineEvent = S.RS.GrabEvents.ExtendGrabLine,
			CreateGrabEvent = S.RS.GrabEvents.CreateGrabLine,
			StruggleEvent = S.RS.CharacterEvents.Struggle,
			StickyPartEvent = S.RS.PlayerEvents.StickyPartEvent,
			BombEvent = S.RS.BombEvents.BombExplode,
			DestroyGrabLineEvent = S.RS.GrabEvents.DestroyGrabLine,
			SetNetworkOwnerEvent = S.RS.GrabEvents.SetNetworkOwner,
			Ragdoll = S.RS.CharacterEvents.RagdollRemote,
			SpawnToyEvent = S.RS.MenuToys.SpawnToyRemoteFunction},

		me = S.Players.LocalPlayer,
		myname = me.Name,
		mouse = me:GetMouse(),
		BeingHeld = me.IsHeld,
		pccontrol = me.PlayerGui.ControlsGui.PCFrame,
		pccontroltoy = pccontrol.ToyMenu,
		backpack = S.w[me.Name.."SpawnedInToys"],
		m = S.w.Map,
		SL = S.w.SpawnLocation,
		stoys = nil,
		pcld = nil,
		backpacks = nil,
		chars = nil,
		hls = nil,
		ccc = S.w.Camera:FindFirstChild("ColorCorrection"),
		sunrays = nil}

	local N = {
		V = {
			mhv3 = Vector3.new(math.huge, math.huge, math.huge),
			nv3 = Vector3.new(0, 0, 0)},

		C1 = {
			Color3.fromRGB(0,0,0),
			Color3.fromRGB(0,255,0),
			Color3.fromRGB(255,255,0),
			Color3.fromRGB(255,0,0)},

		C2 = {
			Color3.fromRGB(0, 255, 255),
			Color3.fromRGB(0,255,0),
			Color3.fromRGB(127,255,0),
			Color3.fromRGB(255,255,0),
			Color3.fromRGB(255,127,0),
			Color3.fromRGB(255,0,0)},

		distallaura = 24,
		gettimefunc = 0,
		xrta = 0,
		expldelay = 0,
		yrta = 0,
		zrta = 0,
		chal = 0,
		cdyat = 0,
		zoombindv = 0,
		chamsot = 0,
		chamsft = 0,
		RawStep2 = 0,
		step2 = 0,
		hpa = 0,
		dpa = 0,
		cpan = 0,
		cpa = 0,
		hta = 0,
		dta = 0,
		RawStep = 0,
		step = 0,
		cat = 0,
		zgv = 0,
		ks = 10,
		last_UTP = 0,
		strength = 0,
		Lag_Intensity = 0,
		kickcountc = 0,
		wss = 0,
		jps = 0,
		gs = 0,
		linecolorscount = 0,
		debug = 4}

	local L = {
		publicds = false,
		spyenabled = false,
		public = false,
		zoombind = false,
		gluegrab = false,
		controltrain = false,
		hidealltoys = false,
		shadowalltoys = false,
		storeallplayerstoys = false,
		vhsows = true,
		debug = false,
		smptmt = false,
		tptoyfs = false,
		spyallplrinfo = true,
		paitd = false}


	local P = {
		gkblob = nil,
		who = nil,
		lplr = nil,
		rplr = nil,
		whll = nil,
		last_toy = nil,
		last_model = nil,
		last_chto = nil,
		last_chto2 = nil,
		spat = nil,
		tptoypos = CFrame.new(363.534424, -7.35040426, 527.307678, 0.425311029, 3.02851468e-08, -0.905047238, 8.34827762e-09, 1, 3.73856288e-08, 0.905047238, -2.34561064e-08, 0.425311029)}

	local Lt = {
		toys = {
			BombMissile = {"HitboxBodyTop", "PartHitDetector"},
			BombDarkMatter = {"PartHitDetector","Spinner"},
			BallSnowball = {"SoundPart"}},

		gps = {
			BombMissile = "HitboxBodyTop",
			BombDarkMatter = "Spinner",
			BallSnowball = "SoundPart"},

		admins = {959216740, 5516434780, 2311784954, 6192858983, 7427155484},
		lat = {},
		hui = {},
		hui2 = {},
		ggl = {},
		ccolors = {},
		privateProperties = {
			Color = Color3.fromRGB(255,0,0),
			Font = Enum.Font.SourceSansBold,
			TextSize = 18},
		last_urls = {},
		spylist = {},
		sspylist = {},
		ftapcolors = {
			Coins = Color3.fromRGB(0, 0, 0),
			TabBar = Color3.fromRGB(0, 0, 0),
			Settings = Color3.fromRGB(66, 66, 66),
			Shop = Color3.fromRGB(0, 0, 0),
			ToyDestroy = Color3.fromRGB(0, 0, 0),
			ToysShop = Color3.fromRGB(0, 0, 0),
			Toys = Color3.fromRGB(0, 0, 0),
			SettingsContents = Color3.fromRGB(90, 90, 90),
			SettingsTitle = Color3.fromRGB(66, 66, 66),
			ShopTitle = Color3.fromRGB(66, 66, 66),
			ShopContents = Color3.fromRGB(90, 90, 90),
			ToysContents = Color3.fromRGB(90, 90, 90),
			FavoritesFrame = Color3.fromRGB(120, 120, 120),
			Favorites = Color3.fromRGB(66, 66, 66),
			MeterFrame = Color3.fromRGB(120, 120, 120),
			SortingTabs = Color3.fromRGB(120, 120, 120),
			ToysTitle = Color3.fromRGB(66, 66, 66),
			DestroyTitle = Color3.fromRGB(66, 66, 66),
			DestroyContents = Color3.fromRGB(90, 90, 90),
			DestroyMeterFrame = Color3.fromRGB(120, 120, 120),
			ToyShopTitle = Color3.fromRGB(66, 66, 66),
			ToyShopSortingTabs = Color3.fromRGB(120, 120, 120),
			ToyShopContents = Color3.fromRGB(90, 90, 90)}}
	
			local Ld = {
				field = function() print("Field function placeholder") end, 
				ppl = {}, 
				bpl = {}, 
				bplid = {},
				bpltag = {}, 
				ldsp = {}, 
				ldsb = {}, 
				ldsbip = {}, 
				lastb = {},
				lastc = {}, 
				lastd = {}  
			}
			
			
	
	local instance = (_G.chatSpyInstance or 0) + 1
	_G.chatSpyInstance = instance
	local chamsfc = Color3.fromRGB(255,255,255)
	local chamsoc = Color3.fromRGB(0,0,0)
	local function set_chams_parametr() end
	local function check_prem() end
	local a = 0
	local debugL1
	local chatFrame = O.me.PlayerGui.Chat.Frame
	me, pccontrol, ldsp, ldsb, ldsbip = nil, nil, nil, nil, nil


	typingAnimation = Instance.new("Animation")
	typingAnimation.AnimationId = "rbxassetid://18353618958"
	typingAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
	typingTrack = typingAnimator:LoadAnimation(typingAnimation)

	crouchAnimation = Instance.new("Animation")
	crouchAnimation.AnimationId = "rbxassetid://6980229055"
	crouchAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
	crouchTrack = crouchAnimator:LoadAnimation(crouchAnimation)

	throwedAnimation = Instance.new("Animation")
	throwedAnimation.AnimationId = "rbxassetid://7047322890"
	throwedAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
	throwedTrack = throwedAnimator:LoadAnimation(throwedAnimation)


	game.Lighting.FogEnd = 1000000000000
	game.Lighting.Sky.StarCount = 5000
	game.Lighting.ShadowSoftness = 1
	game.Lighting.Sky.SkyboxBk = "rbxassetid://1289067181"
	game.Lighting.Sky.SkyboxDn = "rbxassetid://1289084895"
	game.Lighting.Sky.SkyboxFt = "rbxassetid://1289065660"
	game.Lighting.Sky.SkyboxLf = "rbxassetid://1289065992"
	game.Lighting.Sky.SkyboxRt = "rbxassetid://1289066325"
	game.Lighting.Sky.SkyboxUp = "rbxassetid://1289076870"
	game.Lighting.Sky.SunTextureId = "rbxasset://sky/sun.jpg"
	game.Lighting.Sky.MoonTextureId = "rbxasset://sky/moon.jpg"
	O.sunrays = Instance.new("SunRaysEffect", game.Lighting)
	O.sunrays.Intensity = 0
	O.sunrays.Spread = 0

	O.bloomeffect = Instance.new("BloomEffect", game.Lighting)
	O.bloomeffect.Intensity = 0
	O.bloomeffect.Size = 0
	O.bloomeffect.Threshold = 0

	O.ccc = Instance.new("ColorCorrectionEffect", S.w.Camera)
	O.ccc.Enabled = false

	O.hls = Instance.new("Folder", S.w)
	O.hls.Name = _G.heart.."hls".._G.heart

	O.chars = Instance.new("Folder", S.w)
	O.chars.Name = _G.heart.."chars".._G.heart

	O.backpacks = Instance.new("Folder", S.w)
	O.backpacks.Name = _G.heart.."backpacks".._G.heart

	O.pcld = Instance.new("Folder", S.w)
	O.pcld.Name = _G.heart.."pcld".._G.heart

	O.stoys = Instance.new("Folder", S.w)
	O.stoys.Name = _G.heart.."stoys".._G.heart

	chatFrame.ChatChannelParentFrame.Visible = true
	chatFrame.ChatBarParentFrame.Position = chatFrame.ChatChannelParentFrame.Position+UDim2.new(UDim.new(),chatFrame.ChatChannelParentFrame.Size.Y)
	
	pst = true


	local function if3(a1, a2, a3, b1, b2, b3)
		local t = false
		local l = ""; for _,ll in pairs(a1) do l=l..ll end; a1 = l
		local l = ""; for _,ll in pairs(a2) do l=l..ll end; a2 = l
		local l = ""; for _,ll in pairs(a3) do l=l..ll end; a3 = l
		local l = ""; for _,ll in pairs(b1) do l=l..ll end; b1 = l
		local l = ""; for _,ll in pairs(b2) do l=l..ll end; b2 = l
		local l = ""; for _,ll in pairs(b3) do l=l..ll end; b3 = l
		if if3_help(a1, b2, b3) or a1 ~= b1 then t = true
		elseif if3_help(a2, b1, b3) or a2 ~= b2 then t = true
		elseif if3_help(a3, b1, b2) or a3 ~= b3 then t = true end
		return t
	end




	local function auto_invis_touch() end
	local function After_AG() end
	local function set_hl() end
	local function get_all12() end
	local function get_plr() end
	local function get_rank() end

		local function fstatus(text)
			Ld.field:Notify({
				Title = "Function Status",
				Content = text,
				Duration = 5,
				Image = 4483362458
			})
		end

		local function dnotify(text, n)
			if L.debug and N.debug == n then
				Ld.field:Notify({
					Title = "Debug",
					Content = text,
					Duration = 5,	
					Image = 4483362458
				})
			end
		end

		local function notify(text)
			Ld.field:Notify({
				Title = "Notify",
				Content = text,
				Duration = 5,	
				Image = 4483362458
			})
		end

		local function notify2(text1, text2)
			Ld.field:Notify({
				Title = text1,
				Content = text2,
				Duration = 5,	
				Image = 4483362458
			})
		end


			local function magnitude(prt, prt1) return (prt.Position - prt1.Position).Magnitude end
			local function PackColor(Color) return {R = Color.R * 255, G = Color.G * 255, B = Color.B * 255} end
			local function UnpackColor(Color) return Color3.fromRGB(Color.R, Color.G, Color.B) end


			local function check_list(list, find) for _,v in pairs(list) do if v == find then return v end end end
			local function check_limbs(prt) return check_list({"Head","Right Arm","Right Leg","Left Arm","Left Leg","Torso","HumanoidRootPart"}, prt.Name) end
			local function check_hum(hum) if hum and hum.Health ~= 0 and hum:GetState() ~= Enum.HumanoidStateType.Dead then return true end end
			local function check_spy(nk) local t = false; t = check_list(Lt.spylist, nk); t = check_list(Lt.sspylist, nk); return t end
			local function check_whll(nk) return not(check_list(P.whll, nk)) end
			local function check_mag1(prt, prt1) if magnitude(prt, prt1) < 25 then return true end end
			local function check_mag2(prt, prt1) if magnitude(prt, prt1) > 25 then return true end end
			local function check_admin(id) return check_list(Lt.admins, id) end
			local function check_plr(obj, t) local hrp, hum, hd, hrp1, hum1, hd1 = get_all12(obj) 
				if hrp and hum and check_hum(hum) and hd and hrp1 and hum1 and check_hum(hum1) and hd1 and not(get_plr(obj).InPlot.Value) then
					if t then t = check_mag1(hrp, hrp1) else t = true end; if t then return hrp, hum, hd, hrp1, hum1, hd1 end end end
			local function check_rank(plr) if get_rank(O.me) > get_rank(plr) then return true end end
			


			local function get_time() if N.gettimefunc ~= 0 then print(os.clock() - N.gettimefunc); N.gettimefunc = 0 else N.gettimefunc = os.clock() end end
			local function get_end(list) local endd; for _,v in pairs(list) do endd = v end; return endd end
			local function get_endi(list) local enddi; for i,_ in pairs(list) do enddi = i end; return enddi end
			local function get_rotate(list) local rot = {}; local is = get_endi(list); for i,v in pairs(list) do rot[is-i+1] = v end; return rot end
			local function get_parents(obj) local p = obj; local tree = {obj} while p ~= game do p = p.Parent; table.insert(tree, p) end; return tree end
			local function get_child(obj, tree) local last = obj; for _,obj in ipairs(tree) do if last:FindFirstChild(obj) then last = last[obj] end end return last end
			local function get_char(obj) if obj then for _,plr in ipairs(S.Players:GetPlayers()) do local pf; if obj == plr then return plr.Character end; if plr.Character then pf = check_list(get_parents(obj), plr.Character) end; if pf then return pf end end end end
			function get_plr(obj) local char = get_char(obj); for _,plr in ipairs(S.Players:GetPlayers()) do if plr.Character and plr.Character == char then return plr end end end
			local function get_char_child(obj, obj1) local char = get_char(obj); if char and char:FindFirstChild(obj1) then return char[obj1] end end
			local function get_mychar_child(obj) local char = O.me.Character; if char and char:FindFirstChild(obj) then return char[obj] end end
			local function get_hrp() return get_mychar_child("HumanoidRootPart") end
			local function get_hum() return get_mychar_child("Humanoid") end
			local function get_hd() return get_mychar_child("Head") end
			local function get_hrp1(obj) return get_char_child(obj, "HumanoidRootPart") end
			local function get_hum1(obj) return get_char_child(obj, "Humanoid") end
			local function get_hd1(obj) return get_char_child(obj, "Head") end
			local function get_all() return get_hrp(), get_hum(), get_hd() end
			local function get_all1(obj) return get_hrp1(obj), get_hum1(obj), get_hd1(obj) end
			function get_all12(obj) return get_hrp(), get_hum(), get_hd(), get_hrp1(obj), get_hum1(obj), get_hd1(obj) end
			local function get_grabprt(toy) for _,prt in pairs(toy:GetChildren()) do if (prt:IsA("Part") or prt:IsA("MeshPart")) and prt.CanQuery and prt.CanCollide then return prt end end end
			local function get_po(toy) for _,prt in pairs(toy:GetChildren()) do if prt:FindFirstChild("PartOwner") then return prt.PartOwner end end end
			function get_rank(plr) local rank = 0; if not(check_prem(plr.Name)) then rank = 1 end; if check_admin(plr.UserId) then rank = 2 end; if plr == O.me and L.vhsows then rank = 3 end; return rank end


			local function con_LtoS(list) local str = ""; for _,v in pairs(list) do str = str..v end; return str end
			local function con_TtoS(list) local list1 = get_rotate(list); local str = ""; for i,v in pairs(list1) do if i ~= get_endi(list1) then str = str..tostring(v).."." end end; str = str..tostring(get_end(list1)); return str end


			local function invis_touch(a) O.Events.SetNetworkOwnerEvent:FireServer(a,a.CFrame) end
			local function toy_spawn(ToyName,CFrame) O.Events.SpawnToyEvent:InvokeServer(ToyName, CFrame, Vector3.new(0,0,0)) end
			local function toy_spawn1(ToyName) local hd = get_mychar_child("Head") toy_spawn(ToyName, hd.CFrame) end
			local function toy_spawn2(ToyName) local cf = get_mychar_child("HumanoidRootPart").CFrame; toy_spawn(ToyName, cf-Vector3.new(cf.LookVector.X*20, -15, cf.LookVector.Z*20)) end
			local function toy_delete(toy) O.Events.DestroyToyEvent:FireServer(toy) end
			local function toy_explode(BombPHT,PosPart,Pos) local data = {{["Hitbox"] =  BombPHT,["PositionPart"] = PosPart},Pos}; O.Events.BombEvent:FireServer(unpack(data)) end


			local function create_blv(parent, name, value) local bv = Instance.new("BoolValue", parent); bv.Value = value; bv.Name = name ; return bv end
			local function create_ov(parent, name, value) local ov = Instance.new("ObjectValue", parent); ov.Value = value; ov.Name = name ; return ov end
			local function create_sv(parent, name, value) local sv = Instance.new("StringValue", parent); sv.Value = value; sv.Name = name ; return sv end
			local function create_bp(parent, name, pos, maxf, d) local bp = Instance.new("BodyPosition", parent)
				bp.Name = name; bp.MaxForce = maxf; bp.D = d; if pos then bp.Position = pos end; return bp end
			local function create_bp1(parent, name, pos) return create_bp(parent, name, pos, N.V.mhv3, 100) end
			local function create_bg(parent, name, maxt, d, cframe) local bg = Instance.new("BodyGyro", parent)
				bg.Name = name; bg.MaxTorque = maxt; bg.D = d; if cframe then bg.CFrame = cframe end return bg end
			local function create_hl(parent, adr, name, ot, ft, oc, fc) local hl = Instance.new("Highlight", parent); hl.Name = name
				hl.OutlineTransparency = ot; hl.FillTransparency = ft; hl.OutlineColor = oc; hl.FillColor = fc; hl.Adornee = adr; return hl end
			local function create_bv(parent, name, vl, maxf) local vel = Instance.new("BodyVelocity", parent);
				vel.Name = name; vel.Velocity = vl; vel.MaxForce = maxf; return vel end


			local function wait_load(parent, name) while not(parent:FindFirstChild(name)) do task.wait() end; return parent[name] end
			local function wait_load1(parent, tree) for i,name in pairs(tree) do tree[i] = wait_load(parent, name); parent = tree[i] end return unpack(tree) end
			local function wait_load2(parent, tree) for _,name in pairs(tree) do parent = wait_load(parent, name) end; return parent end
			local function wait_load11(parent, childs) for i,name in pairs(childs) do childs[i] = wait_load(parent, name) end; return unpack(childs) end
			local function wait_tload(toy, name) if Lt.toys[name] then return wait_load11(toy, Lt.toys[name]) end end
			local function wait_gpload(toy, name) if Lt.gps[name] then return wait_load(toy, Lt.gps[name]) else return get_grabprt(toy) end end



		local function plr_kill1(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp then
				auto_invis_touch(hd1, hrp)
				invis_touch(hd1)
				for a=1, 100 do
					hrp1.CFrame = hrp1.CFrame + Vector3.new(0, -1000, 0)
					task.wait(0.1)
				end
			end
		end

		local function plr_kill2(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp then
				auto_invis_touch(hd1, hrp)
				invis_touch(hd1)
				for a=1, 100 do
					hrp1.CFrame = hrp1.CFrame + Vector3.new(0, -1000, 0)
					task.wait(0.1)
				end
			end
		end



		local function plr_fling(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp then
				auto_invis_touch(hd1, hrp)
				if not(hrp1:FindFirstChild("pfbv")) then
					local bv = Instance.new("BodyVelocity", hrp1)
					bv.MaxForce = N.V.mhv3
					bv.Name = "pfbv"
					bv.Velocity = Vector3.new(0, math.huge, 0)
					local con = hd1.PartOwner.AncestryChanged:Connect(function()
						bv:Destroy()
					end)
				end
			end
		end

		local function plr_grab(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp then auto_invis_touch(hd1, hrp) end
		end

		local function plr_ragdoll(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp then
				auto_invis_touch(hd1, hrp)
				local save = hrp1.Position
				local bp = create_bp1(hrp1, "rgbp", hrp1.Position + Vector3.new(0, 1000, 0)); task.wait(0.1)
				bp.Position = save + Vector3.new(0, -10, 0); task.wait(0.1)
				bp.Position = save; task.wait(0.1)
				bp:Destroy(); task.wait(0.1)
			end
		end

		local function plr_split(plr, t)
			local hrp, hum, hd, hrp1, hum1, hd1 = check_plr(plr, t)
			if hrp and not(hd1:FindFirstChild("spited")) then
				create_blv(hd1, "spited", true)
				hrp1.Parent.Torso:Destroy()
			end
		end

	--â™¥invis_touchâ™¥
		function auto_invis_touch(prt, hrp, hl, hldata, bp, bg)
			local bv = prt:FindFirstChild("igrab")
			local po = prt:FindFirstChild("PartOwner")
			local sv = prt:FindFirstChild("whograb")
			local con
			if not(sv) then
				sv = create_sv(prt, "whograb", "")
				con = prt.ChildAdded:Connect(function(obj)
					if obj.Name == "PartOwner" then
						sv.Value = obj.Value
					end
				end)
			end
			local function auto()
				set_hl(hl, "FillColor", hldata, 3)
				local save = hrp.CFrame
				local t = false
				local last_pos = prt.Position
				task.spawn(function()
					while (not(po) or po.Value ~= O.myname) and task.wait(0.1) do
						if not(prt.Parent) or not(hrp.Parent) then break end
						if check_hum(hrp.Parent.Humanoid) and last_pos ~= prt.Position then
							last_pos = prt.Position
						end
					end
				end)
				while (not(po) or po.Value ~= O.myname) and task.wait() do
					if not(prt.Parent) or not(hrp.Parent) then break end
					if check_hum(hrp.Parent.Humanoid) then
						if check_mag2(prt, hrp) then
							set_hl(hl, "FillColor", hldata, 4)
							hrp.CFrame = prt.CFrame + ((prt.Position - last_pos)*O.me:GetNetworkPing()*100)
							t = true
							invis_touch(prt)
						else invis_touch(prt) end
					else set_hl(hl, "FillColor", hldata, 5) end
					po = prt:FindFirstChild("PartOwner")
				end
				if t then hrp.CFrame = save end
				set_hl(hl, "FillColor", hldata, 1)
			end
			if sv.Value ~= O.me.Name then auto() end
			if bv then
				set_hl(hl, "FillColor", hldata, 2)
				while not(prt:FindFirstChild("PartOwner")) do task.wait() end
				bp.MaxForce = N.V.nv3
				bg.MaxTorque = N.V.nv3
				while bv.Parent do task.wait() end
				bp.Position = prt.Position
				bg.CFrame = prt.CFrame
				bp.MaxForce = N.V.mhv3
				bg.MaxTorque = N.V.mhv3
				set_hl(hl, "FillColor", hldata, 1)
			end
		end

		local function char_invis_touch(prt, hrp, hl, hldata, bp, bg) auto_invis_touch(wait_load2(get_char, {"Head"}), hrp, hl, hldata, bp, bg) end

		local function safe_invis_touch(prt, hrp, hl, hldata, bp, bg)
			if prt and hrp and prt:IsA("Part") and prt.CollisionGroup == "Items" then
				if check_limbs(prt.Name) then char_invis_touch(prt, hrp, hl, hldata, bp, bg)
				else
					local po = prt:FindFirstChild("PartOwner")
					local save = hrp.CFrame
					local t = false
					local last_pos = prt.Position
					task.spawn(function()
						while t3 and task.wait(0.1) do
							if not(prt.Parent) or not(hrp.Parent) then break end
							if check_hum(hrp.Parent.Humanoid) and last_pos ~= prt.Position then
								last_pos = prt.Position
							end
						end
					end)
					if (not(po) or po.Value ~= O.myname) then
						while (not(po) or po.Value ~= O.myname) and task.wait() do
							if not(prt.Parent) or not(hrp.Parent) then break end
							if check_hum(hrp.Parent.Humanoid) then
								if check_mag2(prt, hrp) then
									hrp.CFrame = prt.CFrame + ((prt.Position - last_pos)*O.me:GetNetworkPing()*100)
									t = true
								else invis_touch(prt) end
							end
							po = get_po(prt.Parent)
						end
						if t then hrp.CFrame = save end
					end
				end
			end
		end
			
		local function loop_invis_touch(prt)
			local v21 = prt:FindFirstChild("ait")
			if not(v21) then
				v21 = Instance.new("ObjectValue", prt)
				v21.Name = "ait"
				local v22 = Instance.new("Highlight", O.hls)
				v22.FillColor = Color3.fromRGB(255, 0, 255)
				v22.OutlineColor = Color3.fromRGB(255, 0, 0)
				v22.FillTransparency = 0.5
				v22.OutlineTransparency = 0
				v22.Adornee = prt
				v22.Name = "aithl"
				v21.Value = v22
				while task.wait() do
					if not(prt.Parent) or not(v21.Parent) or not(v22.Parent) then break end
					local v1 = O.me.Character; if v1 then
						local v2 = v1:FindFirstChild("HumanoidRootPart"); if v2 then
							if check_mag1(v2, prt) then
								invis_touch(prt)
								local save = v22.FillColor
								v22.FillColor = v22.OutlineColor
								v22.OutlineColor = save
								task.wait()
								invis_touch(prt)
								local save = v22.FillColor
								v22.FillColor = v22.OutlineColor
								v22.OutlineColor = save
							end
						end
					end
				end
			end
		end

		local function freeze(prt, hrp)
			local bp = prt:FindFirstChild("fzbp")
			local bg = prt:FindFirstChild("fzbg")
			local hl = prt:FindFirstChild("fzhl")
			if not(bp and bg and hl) then
				local bp = create_bp1(prt, "fzbp", prt.Position)
				local bg = create_bg(prt, "fzbg", N.V.mhv3, 100, prt.CFrame)
				local hl = create_hl(prt, prt.Parent, "fzhl", 0, 0.5, Color3.fromRGB(0, 0, 255), Color3.fromRGB(0, 255, 255))
				while prt.Parent and bp.Parent and bg.Parent and hl.Parent do auto_invis_touch(prt, hrp, hl, N.C2, bp, bg); task.wait() end
			end
		end

	--â™¥spawnsâ™¥
		local function toy_sspawn(name, funcid)
			local hrp, hum = get_all()
			if hrp and hum and check_hum(hum) and not(O.me.InPlot.Value) then
				while not(O.me.CanSpawnToy.Value) do task.wait() end
				if funcid == 1 then task.spawn(toy_spawn1, name) end
				if funcid == 2 then task.spawn(toy_spawn2, name) end
				local toy = wait_load(O.backpack, name.."/n").Value
				O.backpack[name.."/n"]:Destroy()
				return toy
			end
		end

		local function toy_aspawn(name, funcid, hrp)
			local toy = toy_sspawn(name, funcid)
			auto_invis_touch(wait_gpload(toy, name), hrp)
			return toy
		end

		local function toy_void(prt, hrp)
			prt.Parent.Name = prt.Parent.Name.."/v"
			auto_invis_touch(prt ,hrp); if prt.Parent then
				for _,prt in pairs(prt.Parent:GetChildren()) do
					if prt:IsA("Part") or prt:IsA("MeshPart") then
						prt.CanTouch = false
						prt.CanCollide = false
					end
				end
				create_bp1(prt, "vbv", Vector3.new(0, 1111111, 0))
			end
		end

		local function toy_vspawn(name, funcid)
			local toy = toy_sspawn(name, funcid)
			toy_void(wait_gpload(toy, name), get_hrp())
			return toy
		end

	--â™¥setsâ™¥
		function set_hl(hl, choice, data, choice1)
			if hl and choice and data then
				if choice1 then if hl[choice] ~= data[choice1] then hl[choice] = data[choice1] end
				else if hl[choice] ~= data then hl[choice] = data end end
			end
		end

		local function set_ftap_color()
			local Data = {}
			for i,v in pairs(Lt.ftapcolors) do
				Data[i] = PackColor(v)
			end
			writefile("VHS/FTAPColors.vhs",tostring(S.HS:JSONEncode(Data)))

			local plrgui = O.me.PlayerGui
			local tabs = plrgui.MenuGui.Menu.TabBar.Tabs
			local tbcont = plrgui.MenuGui.Menu.TabContents
			local seting = tbcont.Settings
			local shop = tbcont.Shop
			local tbcont_toys = tbcont.Toys
			local tbcont_toysdestroy = tbcont.ToyDestroy
			local tbcont_toyhop = tbcont.ToyShop

			plrgui.MenuGui.TopRight.CoinsFrame.BackgroundColor3 = Lt.ftapcolors.Coins
			plrgui.MenuGui.Menu.TabBar.BackgroundColor3 = Lt.ftapcolors.TabBar
			tabs.Settings.BackgroundColor3 = Lt.ftapcolors.Settings
			tabs.Shop.BackgroundColor3 = Lt.ftapcolors.Shop
			tabs.ToyDestroy.BackgroundColor3 = Lt.ftapcolors.ToyDestroy
			tabs.ToyShop.BackgroundColor3 = Lt.ftapcolors.ToysShop
			tabs.Toys.BackgroundColor3 = Lt.ftapcolors.Toys
			seting.Contents.BackgroundColor3 = Lt.ftapcolors.SettingsContents
			seting.Title.BackgroundColor3 = Lt.ftapcolors.SettingsTitle
			shop.Title.BackgroundColor3 = Lt.ftapcolors.ShopTitle
			shop.Contents.BackgroundColor3 = Lt.ftapcolors.ShopContents
			tbcont_toys.Contents.BackgroundColor3 = Lt.ftapcolors.ToysContents
			tbcont_toys.FavoritesFrame.BackgroundColor3 = Lt.ftapcolors.FavoritesFrame
			tbcont_toys.FavoritesFrame.Favorites.BackgroundColor3 = Lt.ftapcolors.Favorites
			tbcont_toys.MeterFrame.BackgroundColor3 = Lt.ftapcolors.MeterFrame
			tbcont_toys.SortingTabs.BackgroundColor3 = Lt.ftapcolors.SortingTabs
			tbcont_toys.Title.BackgroundColor3 = Lt.ftapcolors.ToysTitle
			tbcont_toysdestroy.Title.BackgroundColor3 = Lt.ftapcolors.DestroyTitle
			tbcont_toysdestroy.Contents.BackgroundColor3 = Lt.ftapcolors.DestroyContents
			tbcont_toysdestroy.MeterFrame.BackgroundColor3 = Lt.ftapcolors.DestroyMeterFrame
			tbcont_toyhop.Title.BackgroundColor3 = Lt.ftapcolors.ToyShopTitle
			tbcont_toyhop.SortingTabs.BackgroundColor3 = Lt.ftapcolors.ToyShopSortingTabs
			tbcont_toyhop.Contents.BackgroundColor3 = Lt.ftapcolors.ToyShopContents
		end

		local function set_chams_parametr()
			for _,plr in ipairs(S.Players:GetPlayers()) do
				local v1 = plr.Character; if v1 then
					local hl = v1:FindFirstChild("cham")
					if not(hl) then hl = Instance.new("Highlight", v1) end
					hl.Name = plr.Name
					hl.Adornee = v1
					hl.Enabled = chamst
					hl.FillColor = chamsfc
					hl.FillTransparency = N.chamsft
					hl.OutlineColor = chamsoc
					hl.OutlineTransparency = N.chamsot
				end
			end
		end

		local function set_line_color()
			local Data = {}
			for i,v in ipairs(Lt.ccolors) do
				Data[i] = PackColor(v)
			end

			writefile("VHS/LineColor.vhs",tostring(S.HS:JSONEncode(Data)))

			local args = {
				ColorSequenceKeypoint.new(0, Lt.ccolors[1]),
				ColorSequenceKeypoint.new(0.10, Lt.ccolors[2]),
				ColorSequenceKeypoint.new(0.15, Lt.ccolors[3]),
				ColorSequenceKeypoint.new(0.20, Lt.ccolors[4]),
				ColorSequenceKeypoint.new(0.25, Lt.ccolors[5]),
				ColorSequenceKeypoint.new(0.30, Lt.ccolors[6]),
				ColorSequenceKeypoint.new(0.35, Lt.ccolors[7]),
				ColorSequenceKeypoint.new(0.40, Lt.ccolors[8]),
				ColorSequenceKeypoint.new(0.45, Lt.ccolors[9]),
				ColorSequenceKeypoint.new(0.50, Lt.ccolors[10]),
				ColorSequenceKeypoint.new(0.55, Lt.ccolors[11]),
				ColorSequenceKeypoint.new(0.60, Lt.ccolors[12]),
				ColorSequenceKeypoint.new(0.65, Lt.ccolors[13]),
				ColorSequenceKeypoint.new(0.70, Lt.ccolors[14]),
				ColorSequenceKeypoint.new(0.75, Lt.ccolors[15]),
				ColorSequenceKeypoint.new(0.80, Lt.ccolors[16]),
				ColorSequenceKeypoint.new(0.85, Lt.ccolors[17]),
				ColorSequenceKeypoint.new(0.90, Lt.ccolors[18]),
				ColorSequenceKeypoint.new(0.95, Lt.ccolors[19]),
				ColorSequenceKeypoint.new(1, Lt.ccolors[20])
			}
			O.Events.SetLineColorEvent:FireServer(ColorSequence.new(args))
		end

		
		local function update_hui()
			Lt.hui = {}
			Lt.hui2 = {}
			local p = "p"
			if L.vhsows then p = "" end
			for _,plr in ipairs(S.Players:GetPlayers()) do
				if plr ~= O.me then
					if not(check_prem(plr.Name)) then
						if plr:IsFriendsWith(O.me.userId) then
							table.insert(Lt.hui, plr.DisplayName.." ("..plr.Name..") â™¦Friendâ™¦ â™¥Premium Userâ™¥")
							Lt.hui2[plr.Name..p] = plr.DisplayName.." ("..plr.Name..") â™¦Friendâ™¦ â™¥Premium Userâ™¥" 
						else
							table.insert(Lt.hui, plr.DisplayName.." ("..plr.Name..") â™¥Premium Userâ™¥")
							Lt.hui2[plr.Name..p] = plr.DisplayName.." ("..plr.Name..") â™¥Premium Userâ™¥" 
						end
					else
						if plr:IsFriendsWith(O.me.userId) then
							table.insert(Lt.hui, plr.DisplayName.." ("..plr.Name..") â™¦Friendâ™¦")
							Lt.hui2[plr.Name] = plr.DisplayName.." ("..plr.Name..") â™¦Friendâ™¦"
						else
							table.insert(Lt.hui, plr.DisplayName.." ("..plr.Name..")")
							Lt.hui2[plr.Name] = plr.DisplayName.." ("..plr.Name..")"
						end
					end
				end
			end
		end; update_hui()

		local function blob_kick(blob,hrp,rl,v)
			local script = blob:FindFirstChild("BlobmanSeatAndOwnerScript"); if script then
				local detec = blob:FindFirstChild(rl.."Detector")
				local grab = script:FindFirstChild("CreatureGrab")
				local drop = script:FindFirstChild("CreatureDrop")
				if detec and grab and drop then
					if v == 1 then
						grab:FireServer(detec,hrp,detec[rl.."Weld"])
					elseif v == 2 then
						drop:FireServer(detec[rl.."Weld"],hrp)
					elseif v == 12 then
						grab:FireServer(detec,hrp,detec[rl.."Weld"])
						drop:FireServer(detec[rl.."Weld"],hrp)
					end
				end
			end
		end

		local function anch_plr()
			O.me.Character.HumanoidRootPart.Anchored = true
			while O.me.Character["Right Arm"].RagdollLimbPart.CanCollide == true do task.wait() end
			O.me.Character.HumanoidRootPart.Anchored = false
		end

		local function reset_gq()
			for _,obj in pairs(S.w:GetDescendants()) do 
				if obj:IsA("Part") and obj:FindFirstChild("gqcs") then
					obj.CastShadow = obj.gqcs.Value
					obj.gqcs:Destroy()
				end
			end
			for _,obj in pairs(S.w:GetDescendants()) do 
				if obj:IsA("Part") and obj:FindFirstChild("gqs") then
					obj.Shadows = obj.gqs.Value
					obj.gqs:Destroy()
				end
			end
			game.MaterialService.Use2022Materials = false
			game.Lighting.Technology = "Voxel"
			game.Lighting.Ambient = Color3.fromRGB(120, 120, 120)
			game.Lighting.OutdoorAmbient = Color3.fromRGB(200, 200, 200)
			O.sunrays.Intensity = 0
			O.sunrays.Spread = 0
			O.bloomeffect.Intensity = 0
			O.bloomeffect.Size = 0
			O.bloomeffect.Threshold = 0
		end


--â™¥forsâ™¥
	for _,plr in ipairs(S.Players:GetPlayers()) do
		if plr ~= O.me then
			if plr.Character then plr.Character.Parent = O.chars end
			if S.w:FindFirstChild(plr.Name.."SpawnedInToys") and plr ~= O.me then
				create_sv(S.w[plr.Name.."SpawnedInToys"], "plr_name", plr.Name)
				S.w[plr.Name.."SpawnedInToys"].Parent = O.backpacks
			end
			plr.CharacterAdded:Connect(function(char)
				char.Parent = O.chars
				set_chams_parametr()
			end)
			-- if plr ~= O.me and plr.InPlot.Value and check_prem(plr.Name) then
			-- 	task.wait()
			-- 	S.w.PlotItems.PlayersInPlots[plr].Parent = S.w
			-- end
		end
	end

	for _,obj in pairs(S.w:GetChildren()) do
		if obj.Name == "PlayerCharacterLocationDetector" then obj.Parent = O.pcld
		else local check = {"Balloons","Cave","Cubes","Drawers",
				"Farm","Food","Furniture","Glass Boxes","Ladders",
				"Large Animals","Lincoln Planks","Music","NOT New",
				"Other","Pallets","Robloxians","Rollers",_G.f2}
			if check_list(check, obj.Name) then obj.Parent = O.stoys end
		end
	end

	for _,prt in pairs(S.w.Plots:GetDescendants()) do if prt.Name == "PlotBarrier" or prt.Name == "PlotArea" then prt.CanQuery = false; prt.CanCollide = false end end



--â™¥connectâ™¥
	S.Players.PlayerAdded:Connect(function(plr)
		plr.CharacterAdded:Connect(function(char)
			if char ~= O.me.Character then
				char.Parent = O.chars
				-- set_chams_parametr()
			end
		end)
		if paitd then post_info(plr) end
		if check_spy(plr.Name) then notify(plr.Name.." ("..plr.DisplayName..") Joined your server") end
		update_hui()
		while not(S.w:FindFirstChild(plr.Name.."SpawnedInToys")) do task.wait() end
		create_sv(S.w[plr.Name.."SpawnedInToys"], "plr_name", plr.Name)
		S.w[plr.Name.."SpawnedInToys"].Parent = O.backpacks
	end)

	S.Players.PlayerRemoving:Connect(function()
		update_hui()
	end)

	O.backpack.ChildAdded:Connect(function(toy)
		if not(toy:IsA("ObjectValue")) then
			local ov = create_ov(toy.Parent, toy.Name.."/n", toy)
			toy.Destroying:Connect(function() ov:Destroy() end)
			if toyaura and sttta and toy.Name ~= "FireExtinguisher" and toy.Name ~= "NinjaKunai" then
				N.cat = N.cat + 1
				table.insert(Lt.lat,toy)
			end
			P.last_toy = toy
		end
	end)

	S.w.ChildAdded:Connect(function(gp)
		if gp.Name == "GrabParts" then
			local wc = wait_load2(gp, {"GrabPart","WeldConstraint"})
			local prt = wc.Part1
			local bv = create_blv(prt, "igrab", true)
			gp.Destroying:Connect(function() bv:Destroy() end)
		end
	end)

    
	S.w.ChildAdded:Connect(function(pcld)
		if pcld.Name == "PlayerCharacterLocationDetector" then
			task.wait(); pcld.Parent = O.pcld
		end
	end)

	S.UIS.JumpRequest:Connect(function()
		local t = true
		if O.me.Character and t and infj then
			t = false
			O.me.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
			task.wait()
			t = true
		end
	end)

	S.w.ChildAdded:Connect(function(f)
		if f.Name == "GrabParts" and not(kickkk1) and not(kickkk2) then
			N.zgv = 0
			local da = f.DragPart.DragAttach
			while f.Parent and task.wait() do da.Position = S.w.Camera.CFrame.LookVector * N.zgv end
		end
	end)

	S.w.ChildAdded:Connect(function(model)
		if model.Name == "GrabParts" and sila then
			local part_to_impulse = model["GrabPart"]["WeldConstraint"].Part1
			if part_to_impulse then
				local velocityObj = Instance.new("BodyVelocity", part_to_impulse)
				model:GetPropertyChangedSignal("Parent"):Connect(function()
					if not model.Parent then
						if S.UIS:GetLastInputType() == Enum.UserInputType.MouseButton2 then
							velocityObj.MaxForce = N.V.mhv3
							velocityObj.Velocity = S.w.CurrentCamera.CFrame.lookVector * N.strength
							S.d:AddItem(velocityObj, 1)
						elseif S.UIS:GetLastInputType() == Enum.UserInputType.MouseButton1 then
							velocityObj:Destroy()
						else
							velocityObj:Destroy()
						end
					end
				end)
			end
		end
	end)



	S.w.ChildAdded:Connect(function(model)--neon
		if model.Name == "GrabParts" and ultragrabbb then
			S.w.GrabParts.DragPart.Color = Color3.fromRGB(255,0,0)
			S.w.GrabParts.DragPart.Transparency = 0
			S.w.GrabParts.DragPart.Material = "Neon"
			model.DragPart.AlignOrientation.Responsiveness = 200
			model.DragPart.AlignOrientation.MaxTorque = "inf"
			model.DragPart.AlignPosition.MaxAxesForce = Vector3.new("inf","inf","inf")
			model.DragPart.AlignPosition.MaxForce = "inf"
			model.DragPart.AlignPosition.Responsiveness = 200
		end
	end)

	S.w.ChildAdded:Connect(function(model)
		if model.Name == "Part" and O.me.Character and antiexpl then
			local mag = (model.Position - O.me.Character.HumanoidRootPart.Position).Magnitude
			if mag <= 18 then
				anch_plr()
			end
		end
	end)

	S.w.DescendantAdded:Connect(function(toy)
		if toy.Name == "CreatureBlobman" and toy.Parent ~= O.backpack and antiblob then
			task.wait()
			wait_load2(toy, {"LeftDetector","AttachPlayer"}):Destroy()
			wait_load2(toy, {"RightDetector","AttachPlayer"}):Destroy()
		end
	end)

	S.w.PlotItems.Plot1.ChildAdded:Connect(function(toy)
		if toy.Name == "PlantPottedCactus" then
			task.wait()
			toy:Destroy()
		end
	end)

	S.w.PlotItems.Plot2.ChildAdded:Connect(function(toy)
		if toy.Name == "PlantPottedCactus" then
			task.wait()
			toy:Destroy()
		end
	end)

	S.w.PlotItems.Plot3.ChildAdded:Connect(function(toy)
		if toy.Name == "PlantPottedCactus" then
			task.wait()
			toy:Destroy()
		end
	end)

	S.w.PlotItems.Plot4.ChildAdded:Connect(function(toy)
		if toy.Name == "PlantPottedCactus" then
			task.wait()
			toy:Destroy()
		end
	end)

	S.w.PlotItems.Plot5.ChildAdded:Connect(function(toy)
		if toy.Name == "PlantPottedCactus" then
			task.wait()
			toy:Destroy()
		end
	end)

	S.w.PlotItems.PlayersInPlots.ChildAdded:Connect(function(plr)--anti dom
		if plr ~= O.me and check_prem(plr.Name) then
			task.wait()
			plr.Parent = O.chars
		end
	end)

	O.me.CharacterAdded:Connect(function()
		typingAnimation = Instance.new("Animation")
		typingAnimation.AnimationId = "rbxassetid://18353618958"
		typingAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
		typingTrack = typingAnimator:LoadAnimation(typingAnimation)

		crouchAnimation = Instance.new("Animation")
		crouchAnimation.AnimationId = "rbxassetid://6980229055"
		crouchAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
		crouchTrack = crouchAnimator:LoadAnimation(crouchAnimation)

		throwedAnimation = Instance.new("Animation")
		throwedAnimation.AnimationId = "rbxassetid://7047322890"
		throwedAnimator = O.me.Character:WaitForChild("Humanoid"):WaitForChild("Animator")
		throwedTrack = throwedAnimator:LoadAnimation(throwedAnimation)
	end)

	S.UIS.InputChanged:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseWheel and zgt then
			local v1 = S.w:FindFirstChild("GrabParts"); if v1 then
				if inp.Position.Z == 1 then N.zgv = N.zgv + 3 else N.zgv = N.zgv - 3 end
			else N.zgv = 0 end
		end
	end)

	S.Players.PlayerAdded:Connect(function(p)
		p.Chatted:Connect(function(msg)
			chat_msg(p,msg)
		end)
	end)

--GUI--
local Window = Rayfield:CreateWindow({
    Name = "Loop Kill (Vhs v6)",
    Icon = 0,
    LoadingTitle = "Vhs V6",
    LoadingSubtitle = "By Jose",
    Theme = "Default",
 
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
 
    ConfigurationSaving = {
       Enabled = true,
       FolderName = nil,
       FileName = "vhs v6"
    },
 
    Discord = {
       Enabled = false,
       Invite = "noinvitelink",
       RememberJoins = true
    },
 
    KeySystem = false,
    KeySettings = {
       Title = "Untitled",
       Subtitle = "Key System",
       Note = "No method of obtaining the key is provided",
       FileName = "Key",
       SaveKey = true,
       GrabKeyFromSite = false,
       Key = {"Hello"}
	}
})


if L.vhsows then
local killtab = Window:CreateTab("Players Menu", 7733674079)

	local kickcount1 = killtab:CreateLabel("Kicked: "..N.kickcountc)

	killtab:CreateSection("Kill")

		killtab:CreateButton({
			Name = "Kill Player",
			Callback = function()
				for _,plr in pairs(P.who) do
					if S.Players:FindFirstChild(plr) then
						plr_kill2(S.Players[plr])
					end
				end
			end,
		})

		killtab:CreateToggle({
			Name = "Loop Kill Player",
			CurrentValue = false,
			Callback = function(Value)
				loopkill = Value
				while loopkill and task.wait() do
					for _,plr in pairs(P.who) do
						if S.Players:FindFirstChild(plr) then
							plr_kill2(S.Players[plr])
						end
					end
				end
			end,
		})

		killtab:CreateButton({
			Name = "Kill All Players",
			Callback = function()
				for _,plr in ipairs(S.Players:GetPlayers()) do
					plr_kill2(plr)
				end
			end,
		})

local liststab = Window:CreateTab("Players Lists", 7733674079)

	local function create_players_lists()
		update_hui()
		liststab:CreateSection("Players Menu")
		liststab:CreateDropdown({
			Name = "Kill List",
			Options = Lt.hui,
			CurrentOption = {""},
			MultipleOptions = true,
			Flag = "PlayersList", 
			Callback = function(Option)
				P.who = {}
				for i,v in pairs(Option) do
					for i2,v2 in pairs(Lt.hui2) do
						if v == v2 then table.insert(P.who, i2) end
					end
				end
			end,
		})

		liststab:CreateSection("Others")
		liststab:CreateDropdown({
			Name = "White List",
			Options = Lt.hui,
			CurrentOption = {""},
			MultipleOptions = true,
			Flag = "WhiteList", 
			Callback = function(Option)
				P.whll = {"f"}
				for i,v in pairs(Option) do
					for i2,v2 in pairs(Lt.hui2) do
						if v == v2 then table.insert(P.whll, i2) end
					end
				end
			end,
		})

		liststab:CreateDropdown({
			Name = "Join Notify(Temp) List",
			Options = Lt.hui,
			CurrentOption = {""},
			MultipleOptions = true,
			Flag = "SpyList", 
			Callback = function(Option)
				Lt.spylist = {"f"}
				for i,v in pairs(Option) do
					for i2,v2 in pairs(Lt.hui2) do
						if v == v2 then table.insert(Lt.spylist, i2) end
					end
				end
			end,
		})
	end

	

	liststab:CreateKeybind({
		Name = "Kill",
		CurrentKeybind = "",
		HoldToInteract = false,
		Flag = "Add/RemovePlayertoPlayersList", 
		Callback = function(Keybind)
			local v1 = O.mouse.target
			local check = {"Head","Right Arm","Left Arm","Torso","Right Leg","Left Leg","HumanoidRootPart","FirePlayerPart"}
			for _,v in pairs(check) do 
				if v == v1.Name and check_prem(v1.Parent.Name) then
					local t = true
					for i,v in pairs(P.who) do 
						if v == v1.Parent.Name then 
							table.remove(P.who, i)
							fstatus(v..": Remove from Players List")
							t = false
							break
						end
					end
					if t then
						table.insert(P.who, v1.Parent.Name)
						fstatus(v1.Parent.Name..": Add from Players List")
					end
					break
				end
			end
		end,
	})

	liststab:CreateKeybind({
		Name = "White",
		CurrentKeybind = "",
		HoldToInteract = false,
		Flag = "Add/RemovePlayertoWhiteList", 
		Callback = function(Keybind)
			local v1 = O.mouse.target
			local check = {"Head","Right Arm","Left Arm","Torso","Right Leg","Left Leg","HumanoidRootPart","FirePlayerPart"}
			for _,v in pairs(check) do 
				if v == v1.Name and check_prem(v1.Parent.Name) then
					local t = true
					for i,v in pairs(P.whll) do 
						if v == v1.Parent.Name then 
							table.remove(P.whll, i)
							fstatus(v..": Remove from White List")
							t = false
							break
						end
					end
					if t then
						table.insert(P.whll, v1.Parent.Name)
						fstatus(v1.Parent.Name..": Add from White List")
					end
					break
				end
			end
		end,
	})

	liststab:CreateKeybind({
		Name = "Join Notify(Temp)",
		CurrentKeybind = "",
		HoldToInteract = false,
		Flag = "Add/RemovePlayertoSpyList(Temp)", 
		Callback = function(Keybind)
			local v1 = O.mouse.target
			local check = {"Head","Right Arm","Left Arm","Torso","Right Leg","Left Leg","HumanoidRootPart","FirePlayerPart"}
			for _,v in pairs(check)  do 
				if v == v1.Name and check_prem(v1.Parent.Name) then
					local t = true
					for i,v in pairs(Lt.spylist) do
						if v == v1.Parent.Name then 
							table.remove(Lt.spylist, i)
							fstatus(v..": Remove from Spy List(Temp)")
							t = false
							break
						end
					end
					if t then
						table.insert(Lt.spylist, v1.Parent.Name)
						fstatus(v1.Parent.Name..": Add from Spy List(Temp)")
					end
					break
				end
			end
		end,
	})

	liststab:CreateKeybind({
		Name = "Join Notify(Save)",
		CurrentKeybind = "",
		HoldToInteract = false,
		Flag = "Add/RemovePlayertoSpyList(Save)", 
		Callback = function(Keybind)
			local v1 = O.mouse.target
			local check = {"Head","Right Arm","Left Arm","Torso","Right Leg","Left Leg","HumanoidRootPart","FirePlayerPart"}
			for _,v in pairs(check)  do 
				if v == v1.Name and check_prem(v1.Parent.Name) then
					local t = true
					local t2 = true
					for i,v in pairs(Lt.sspylist) do
						if v == v1.Parent.Name then 
							table.remove(Lt.sspylist, i)
							fstatus(v..": Remove from Spy List(Save)")
							writefile("VHS/sspylist.vhs",tostring(S.HS:JSONEncode(Lt.sspylist)))
							t = false
							break
						end
					end
					for i,v in pairs(Lt.spylist) do
						if v == v1.Parent.Name then
							if not(t) then 
								table.remove(Lt.spylist, i)
								fstatus(v..": Remove from Spy List(Temp)")
							end
							t2 = false
							break
						end
					end
					if t then
						table.insert(Lt.sspylist, v1.Parent.Name)
						fstatus(v1.Parent.Name..": Add from Spy List(Save)")
						writefile("VHS/sspylist.vhs",tostring(S.HS:JSONEncode(Lt.sspylist)))
					end
					if t2 then
						table.insert(Lt.spylist, v1.Parent.Name)
						fstatus(v1.Parent.Name..": Add from Spy List(Temp)")
					end
					break
				end
			end
		end,
	})

	create_players_lists()
end




if get_rank(O.me) > 1 then
	local msg = ""
	if check_list(Lt.admins, O.me.UserId) then msg = "" end
	if L.vhsows then msg = "" end
	O.Events.saymsg:FireServer(""..msg, "ALL")
	O.Events.saymsg:FireServer("", "All")
end

task.delay(1, function() Lt.ftapcolors = Ld.field.Theme.ftapc end)
task.delay(1, function() chamsfc = Ld.field.Theme.FillColor end)
task.delay(1, function() chamsoc = Ld.field.Theme.OutlineColor end)
task.delay(1, function() Ld.field:ChangeTheme("Default2") end)
task.delay(1, function() set_chams_parametr() end)
task.delay(1, function() set_ftap_color() end)
task.delay(1, function() set_line_color() end)
task.delay(1, function() datadssend() end)

Ld.field:LoadConfiguration()


  	end    
})

local players = game:GetService("Players")
local localPlayer = players.LocalPlayer

local function teleportToPlayer(targetPlayer)
    if targetPlayer and targetPlayer.Character then
        local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and targetHRP then
            localPlayer.Character.HumanoidRootPart.CFrame = targetHRP.CFrame
        end
    end
end

local function getPlayersList()
    local playerList = {}
    for _, player in ipairs(players:GetPlayers()) do
        table.insert(playerList, player.Name .. " (." .. player.DisplayName .. ")")
    end
    return playerList
end

local selectedPlayer = nil
local teleportingActive = false

loopTab:AddSection({
    Name = "Loop Teleport"
})

local dropdown = loopTab:AddDropdown({
    Name = "Select Player",
    Default = nil,
    Options = getPlayersList(),
    Callback = function(Value)
        local playerName = Value:match("^(.-) %(")
        selectedPlayer = players:FindFirstChild(playerName)
        print("Selected: " .. playerName)
    end    
})

players.PlayerAdded:Connect(function()
    dropdown:Refresh(getPlayersList(), true)
end)

players.PlayerRemoving:Connect(function()
    dropdown:Refresh(getPlayersList(), true)
end)

loopTab:AddButton({
    Name = "Teleport",
    Callback = function()
        if selectedPlayer then
            teleportToPlayer(selectedPlayer)
        end
    end
})

loopTab:AddToggle({
    Name = "Loop Teleport",
    Default = false,
    Callback = function(Value)
        teleportingActive = Value
        while teleportingActive do
            if selectedPlayer then
                teleportToPlayer(selectedPlayer)
            end
            task.wait(0)
        end
    end    
})

loopTab:AddSection({
	Name = "Loop Kick Blobman"
})


local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local localPlayer = Players.LocalPlayer
local blobAlter = 1
local fullScriptEnabled = false
local selectedPlayers = {}

local function blobGrabPlayer(player, blobman)
    if not fullScriptEnabled or not player.Character then return end
    
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    local detector = blobAlter == 1 and blobman:FindFirstChild("LeftDetector") or blobman:FindFirstChild("RightDetector")
    
    if detector and humanoidRootPart then
        local weldName = blobAlter == 1 and "LeftWeld" or "RightWeld"
        local args = { detector, humanoidRootPart, detector:FindFirstChild(weldName) }
        
        blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
        blobAlter = (blobAlter == 1) and 2 or 1
    end
end

local function startBlobmanControl()
    local blobmanCoroutine = coroutine.create(function()
        local blobman = nil
        
        for _, v in ipairs(Workspace:GetDescendants()) do
            if v.Name == "CreatureBlobman" and v:FindFirstChild("VehicleSeat") and v.VehicleSeat:FindFirstChild("SeatWeld") then
                if v.VehicleSeat.SeatWeld.Part1 == localPlayer.Character.HumanoidRootPart then
                    blobman = v
                    break
                end
            end
        end
        
        if not blobman then
            warn("No mounted blobman found")
            return
        end
        
        while fullScriptEnabled do
            for playerName in pairs(selectedPlayers) do
                local player = Players:FindFirstChild(playerName)
                if player then
                    blobGrabPlayer(player, blobman)
                end
            end
            task.wait()
        end
    end)
    
    coroutine.resume(blobmanCoroutine)
end

local playerOptions = {}
for _, player in ipairs(Players:GetPlayers()) do
    table.insert(playerOptions, player.Name)
end

local selectedPlayerToAdd, selectedPlayerToRemove

local playerDropdown = loopTab:AddDropdown({
    Name = "Select Players to Add",
    Options = {},
    Callback = function(player) 
        selectedPlayerToAdd = player 
    end
})

local selectedPlayersDropdown = loopTab:AddDropdown({
    Name = "players who will be loop kick blobman",
    Options = {},
    Callback = function(player) 
        selectedPlayerToRemove = player 
    end
})

local function updatePlayerDropdown()
    local playerOptions = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and not selectedPlayers[player.Name] then
            local displayOption = player.Name .. " (" .. player.DisplayName .. ")"
            table.insert(playerOptions, displayOption)
        end
    end
    playerDropdown:Refresh(playerOptions, true)
end

local function updateSelectedPlayersDropdown()
    local playerNames = {}
    for playerName in pairs(selectedPlayers) do
        table.insert(playerNames, playerName)
    end
    selectedPlayersDropdown:Refresh(playerNames, true)
end

Players.PlayerAdded:Connect(updatePlayerDropdown)
Players.PlayerRemoving:Connect(updatePlayerDropdown)
updatePlayerDropdown()

loopTab:AddButton({
    Name = "Add Player",
    Callback = function()
        if selectedPlayerToAdd then
            local username = selectedPlayerToAdd:match("^(.-) %(") or selectedPlayerToAdd
            selectedPlayers[username] = true
            updatePlayerDropdown()
            updateSelectedPlayersDropdown()
            selectedPlayerToAdd = nil
        end
    end
})

loopTab:AddButton({
    Name = "Remove player",
    Callback = function()
        if selectedPlayerToRemove then
            local username = selectedPlayerToRemove:match("^(.-) %(") or selectedPlayerToRemove
            selectedPlayers[username] = nil
            updatePlayerDropdown()
            updateSelectedPlayersDropdown()
            selectedPlayerToRemove = nil
        end
    end
})

loopTab:AddToggle({
    Name = "Loop Kick [Blobman]",
    Default = false,
    Callback = function(enabled)
        fullScriptEnabled = enabled
        if enabled then
            startBlobmanControl()
        else
        
        end
    end
})



local Section = loopTab:AddSection({
	Name = "Loop Bring"
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SetNetworkOwner = ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("SetNetworkOwner")
local localPlayer = Players.LocalPlayer

local teleportPosition = Vector3.new(350.7272644042969, -7.35040283203125, -101.56575775146484)
local selectedPlayer = nil
local loopBringActive = false
local playerDropdown
local lastPlayerList = {}

local function getPlayerList()
    local playerOptions = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            table.insert(playerOptions, player.Name .. " [Or] " .. player.DisplayName .. ".")
        end
    end
    return playerOptions
end

local function updatePlayerDropdown()
    local newPlayerList = getPlayerList()
    
    if table.concat(newPlayerList) ~= table.concat(lastPlayerList) then
        lastPlayerList = newPlayerList
        if playerDropdown then
            playerDropdown:Refresh(newPlayerList, "None")
        end
    end
end

playerDropdown = loopTab:AddDropdown({
    Name = "Select Player",
    Default = "None",
    Options = getPlayerList(),
    Callback = function(Value)
        for _, player in pairs(Players:GetPlayers()) do
            local optionName = player.Name .. " [Or] " .. player.DisplayName .. "."
            if optionName == Value then
                selectedPlayer = player
                break
            end
        end
        print("Selected player: " .. (selectedPlayer and selectedPlayer.Name or "None"))
    end
})

task.spawn(function()
    while true do
        updatePlayerDropdown()
        task.wait(1)
    end
end)

loopTab:AddToggle({
    Name = "Loop Bring",
    Default = false,
    Callback = function(enabled)
        loopBringActive = enabled
        if enabled and selectedPlayer then
            while loopBringActive do
                if selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local torso = selectedPlayer.Character.HumanoidRootPart
                    SetNetworkOwner:FireServer(torso, localPlayer.Character.HumanoidRootPart.CFrame)
                    
                    localPlayer.Character.HumanoidRootPart.CFrame = torso.CFrame
                    torso.CFrame = CFrame.new(teleportPosition)
                end
                task.wait(0.5)
            end
        end
    end
})

loopTab:AddButton({
    Name = "Set Teleport Position",
    Callback = function()
        teleportPosition = localPlayer.Character.HumanoidRootPart.Position
        print("Teleport position set to:", teleportPosition)
    end
})

local Section = loopTab:AddSection({
    Name = "Loop Remove Anti Kick"
})



loopTab:AddButton({
	Name = "Loop Remove Anti Kick (Orion)",
	Callback = function()

local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/ionlyusegithubformcmods/1-Line-Scripts/main/Mobile%20Friendly%20Orion')))() 

local Window = OrionLib:MakeWindow({Name = "Loop Player", HidePremium = false, SaveConfig = true, ConfigFolder = "OrionTest"})


local ExplosionTab = Window:MakeTab({
    Name = "Loop Player",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

local Section = ExplosionTab:AddSection({
	Name = "Loop Remove Anti Kick"
})


local player = game.Players.LocalPlayer
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local WhitelistedPlayers = {}
local selectedWhitelistPlayer = nil

local selectedPlayers = {}

local whitelistDropdown = ExplosionTab:AddDropdown({
    Name = "Select Player",
    Options = {},
    Callback = function(player)
        selectedPlayers[player] = true
    end
})

local whitelistedDropdown = ExplosionTab:AddDropdown({
    Name = "Whitelisted Players",
    Options = {},
    Callback = function(player)
        selectedWhitelistPlayer = player
    end
})

local function updateWhitelistDropdown()
    local playerNames = {}
    for playerName in pairs(WhitelistedPlayers) do
        table.insert(playerNames, playerName)
    end
    whitelistedDropdown:Refresh(playerNames, true)
end

local function updatePlayerDropdown()
    local playerOptions = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player and not WhitelistedPlayers[p.Name] then
            local displayOption = p.Name .. " (" .. p.DisplayName .. ")"
            table.insert(playerOptions, displayOption)
        end
    end
    whitelistDropdown:Refresh(playerOptions, true)
end

Players.PlayerAdded:Connect(updatePlayerDropdown)
Players.PlayerRemoving:Connect(updatePlayerDropdown)

updatePlayerDropdown()
updateWhitelistDropdown()

ExplosionTab:AddButton({
    Name = "Add Player",
    Callback = function()
        for playerName in pairs(selectedPlayers) do
            local username = playerName:match("^(.-) %(") or playerName
            WhitelistedPlayers[username] = true
        end
        updateWhitelistDropdown()
        updatePlayerDropdown()
        selectedPlayers = {}
    end
})

ExplosionTab:AddButton({
    Name = "Remove Player",
    Callback = function()
        for playerName in pairs(WhitelistedPlayers) do
            local username = playerName:match("^(.-) %(") or playerName
            WhitelistedPlayers[username] = nil
        end
        updateWhitelistDropdown()
        updatePlayerDropdown()
        WhitelistedPlayers = {}
    end
})

ExplosionTab:AddButton({
    Name = "Loop Remove Anti Kick",
    Callback = function()
        if not selectedWhitelistPlayer then
            OrionLib:MakeNotification({
                Name = "Erro",
                Content = "Selecione um jogador na whitelist!",
                Time = 2
            })
            return
        end
        
        local targetName = selectedWhitelistPlayer
        
        local originalPosition = player.Character.HumanoidRootPart.Position
        local originalCFrame = player.Character.HumanoidRootPart.CFrame

        player.Character.HumanoidRootPart.CFrame = CFrame.new(-360.707764, -7.35040379, -336.532837, 0.925765216, -1.08088978e-08, 0.378098905, -2.19965379e-08, 1, 8.24454318e-08, -0.378098905, -8.46419752e-08, 0.925765216)

        local args = {
            [1] = "SprayCanWD",
            [2] = CFrame.new(-360.5588073730469, -5.542520999908447, -336.1681213378906, 0.9257686734199524, -0.23281508684158325, 0.29790857434272766, 0, 0.7879294753074646, 0.6157656311988831, -0.37809041142463684, -0.5700565576553345, 0.7294403910636902),
            [3] = Vector3.new(0, 22.21500015258789, 0)
        }

        ReplicatedStorage:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction"):InvokeServer(unpack(args))

        local spawnedInToys = workspace:FindFirstChild(player.Name .. "SpawnedInToys")

        if spawnedInToys then
            local sprayCan = spawnedInToys:FindFirstChild("SprayCanWD")
            if sprayCan then
                local hitbox = sprayCan:FindFirstChild("Hitbox")
                if hitbox then
                    local args = {
                        [1] = hitbox,
                        [2] = hitbox.CFrame
                    }

                    ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("SetNetworkOwner"):FireServer(unpack(args))
                end
            end
        end

        player.Character.HumanoidRootPart.CFrame = originalCFrame

        local sprayCan = workspace:FindFirstChild(player.Name .. "SpawnedInToys"):FindFirstChild("SprayCanWD")
        local stickyRemoverPart = sprayCan and sprayCan:FindFirstChild("StickyRemoverPart")

        if stickyRemoverPart then
            stickyRemoverPart.Size = stickyRemoverPart.Size * 15
        end

        local targetPlayer = workspace:FindFirstChild(targetName)

        while targetPlayer and targetPlayer:FindFirstChild("Head") and stickyRemoverPart do
            stickyRemoverPart.Position = targetPlayer.Head.Position
            wait()
        end
    end
})
  	end    
})

OrionLib:Init()
end

NightHub()